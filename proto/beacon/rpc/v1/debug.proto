syntax = "proto3";

package ethereum.beacon.rpc.v1;

import "google/api/annotations.proto";
import "google/protobuf/empty.proto";

// Debug service API
//
// The debug service in Prysm provides API access to various utilities
// for debugging the beacon node's functionality at runtime, such as being able
// to retrieve the beacon state by block root or state root from the node directly.
service Debug {
    // Returns a beacon state by filter criteria from the beacon node.
    rpc GetBeaconState(BeaconStateRequest) returns (SSZResponse) {
        option (google.api.http) = {
            get: "/eth/v1alpha1/debug/state"
        };
    }
    // Returns a beacon state by filter criteria from the beacon node.
    rpc GetBlock(BlockRequest) returns (SSZResponse) {
        option (google.api.http) = {
            get: "/eth/v1alpha1/debug/block"
        };
    }
    // SetLoggingLevel sets the log-level of the beacon node programmatically.
    rpc SetLoggingLevel(LoggingLevelRequest) returns (google.protobuf.Empty) {
        option (google.api.http) = {
            post: "/eth/v1alpha1/debug/logging"
        };
    }
    // Returns a proto array fork choice object from the beacon node.
    rpc GetProtoArrayForkChoice(google.protobuf.Empty) returns (ProtoArrayForkChoiceResponse) {
        option (google.api.http) = {
            get: "/eth/v1alpha1/debug/forkchoice"
        };
    }
    // Returns a list of validators individual vote status of a given epoch.
    rpc GetIndividualVotes(IndividualVotesRequest) returns (IndividualVotesRespond) {
        option (google.api.http) = {
            get: "/eth/v1alpha1/debug/individual_votes"
        };
    }
}

message BeaconStateRequest {
    oneof query_filter {
        // The slot corresponding to a desired beacon state.
        uint64 slot = 1;

        // The block root corresponding to a desired beacon state.
        bytes block_root = 2;
    }
}

message BlockRequest {
    bytes block_root = 1;
}

message SSZResponse {
    // Returns an ssz-encoded byte slice as a response.
    bytes encoded = 1;
}

message LoggingLevelRequest {
    // The logging levels available in Prysm as an enum.
    enum Level {
        INFO = 0;
        DEBUG = 1;
        TRACE = 2;
    }
    Level level = 1;
}

message ProtoArrayForkChoiceResponse {
    // The prune threshold of how many nodes allowed in proto array store.
    uint64 prune_threshold = 1;
    // Latest justified epoch in proto array store.
    uint64 justified_epoch = 2;
    // Latest finalized epoch in proto array store.
    uint64 finalized_epoch = 3;
    // The list of the proto array nodes in store.
    repeated ProtoArrayNode proto_array_nodes = 4;
    // Root to indices mapping of the proto array nodes in store.
    map<string, uint64> indices = 5;
}

message ProtoArrayNode {
    // Slot of the proto array node.
    uint64 slot = 1;
    // Root of the proto array node.
    bytes root = 2;
    // Parent of the proto array node.
    uint64 parent = 3;
    // Justified epoch of the current proto array node.
    uint64 justified_epoch = 4;
    // finalized epoch of the current proto array node.
    uint64 finalized_epoch = 5;
    // Current weight of the current proto array node.
    uint64 weight = 6;
    // Best child of the current proto array node.
    uint64 best_child = 7;
    // Best descendant of the proto array node.
    uint64 best_descendant = 8;
}

message IndividualVotesRequest {
    // Epoch of the request.
    uint64 epoch = 1;
    // Validator 48 byte BLS public keys to filter validators for the given epoch.
    repeated bytes public_keys = 2;
    // Validator indices to filter validators for the given epoch.
    repeated uint64 indices = 3;
}

message IndividualVotesRespond {
    message IndividualVote {
        // The epoch of the request.
        uint64 epoch = 1;
        // The public key of the request.
        bytes public_key = 2;
        // The validator index of the request.
        uint64 validator_index = 3;
        // Has the validator been slashed.
        bool is_slashed = 4;
        // Is the validator withdrawable.
        bool is_withdrawable_in_current_epoch = 5;
        // Is the validator active in current epoch.
        bool is_active_in_current_epoch = 6;
        // Was the validator active in previous epoch.
        bool is_active_in_previous_epoch = 7;
        // Did validator attest for current epoch.
        bool is_current_epoch_attester = 8;
        // Did validator attest target for current epoch.
        bool is_current_epoch_target_attester = 9;
        // Did validator attest for previous epoch.
        bool is_previous_epoch_attester = 10;
        // Did validator attest target for previous epoch.
        bool is_previous_epoch_target_attester = 11;
        // Did validator attest head for previous epoch.
        bool is_previous_epoch_head_attester = 12;
        // The current effective balance of the validator.
        uint64 current_epoch_effective_balance_gwei = 13;
        // The slots of when the validator's attestation got included in the block.
        uint64 inclusion_slot = 14;
        // How many slots have passed until the validator's attestation got included in the block.
        uint64 inclusion_distance = 15;
    }

    repeated IndividualVote individual_votes = 1;
}
