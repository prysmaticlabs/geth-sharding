// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: proto/beacon/db/powchain.proto

package db

import (
	fmt "fmt"
	io "io"
	math "math"
	math_bits "math/bits"

	proto "github.com/gogo/protobuf/proto"
	v1alpha1 "github.com/prysmaticlabs/ethereumapis/eth/v1alpha1"
	v1 "github.com/prysmaticlabs/prysm/proto/beacon/p2p/v1"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type ETH1ChainData struct {
	CurrentEth1Data      *LatestETH1Data   `protobuf:"bytes,1,opt,name=current_eth1_data,json=currentEth1Data,proto3" json:"current_eth1_data,omitempty"`
	ChainstartData       *ChainStartData   `protobuf:"bytes,2,opt,name=chainstart_data,json=chainstartData,proto3" json:"chainstart_data,omitempty"`
	BeaconState          *v1.BeaconState   `protobuf:"bytes,3,opt,name=beacon_state,json=beaconState,proto3" json:"beacon_state,omitempty"`
	Trie                 *SparseMerkleTrie `protobuf:"bytes,4,opt,name=trie,proto3" json:"trie,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *ETH1ChainData) Reset()         { *m = ETH1ChainData{} }
func (m *ETH1ChainData) String() string { return proto.CompactTextString(m) }
func (*ETH1ChainData) ProtoMessage()    {}
func (*ETH1ChainData) Descriptor() ([]byte, []int) {
	return fileDescriptor_338787f8da2f3d61, []int{0}
}
func (m *ETH1ChainData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ETH1ChainData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ETH1ChainData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ETH1ChainData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ETH1ChainData.Merge(m, src)
}
func (m *ETH1ChainData) XXX_Size() int {
	return m.Size()
}
func (m *ETH1ChainData) XXX_DiscardUnknown() {
	xxx_messageInfo_ETH1ChainData.DiscardUnknown(m)
}

var xxx_messageInfo_ETH1ChainData proto.InternalMessageInfo

func (m *ETH1ChainData) GetCurrentEth1Data() *LatestETH1Data {
	if m != nil {
		return m.CurrentEth1Data
	}
	return nil
}

func (m *ETH1ChainData) GetChainstartData() *ChainStartData {
	if m != nil {
		return m.ChainstartData
	}
	return nil
}

func (m *ETH1ChainData) GetBeaconState() *v1.BeaconState {
	if m != nil {
		return m.BeaconState
	}
	return nil
}

func (m *ETH1ChainData) GetTrie() *SparseMerkleTrie {
	if m != nil {
		return m.Trie
	}
	return nil
}

type LatestETH1Data struct {
	BlockHeight          uint64   `protobuf:"varint,2,opt,name=block_height,json=blockHeight,proto3" json:"block_height,omitempty"`
	BlockTime            uint64   `protobuf:"varint,3,opt,name=block_time,json=blockTime,proto3" json:"block_time,omitempty"`
	BlockHash            [][]byte `protobuf:"bytes,4,rep,name=block_hash,json=blockHash,proto3" json:"block_hash,omitempty"`
	LastRequestedBlock   uint64   `protobuf:"varint,5,opt,name=last_requested_block,json=lastRequestedBlock,proto3" json:"last_requested_block,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LatestETH1Data) Reset()         { *m = LatestETH1Data{} }
func (m *LatestETH1Data) String() string { return proto.CompactTextString(m) }
func (*LatestETH1Data) ProtoMessage()    {}
func (*LatestETH1Data) Descriptor() ([]byte, []int) {
	return fileDescriptor_338787f8da2f3d61, []int{1}
}
func (m *LatestETH1Data) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LatestETH1Data) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LatestETH1Data.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LatestETH1Data) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LatestETH1Data.Merge(m, src)
}
func (m *LatestETH1Data) XXX_Size() int {
	return m.Size()
}
func (m *LatestETH1Data) XXX_DiscardUnknown() {
	xxx_messageInfo_LatestETH1Data.DiscardUnknown(m)
}

var xxx_messageInfo_LatestETH1Data proto.InternalMessageInfo

func (m *LatestETH1Data) GetBlockHeight() uint64 {
	if m != nil {
		return m.BlockHeight
	}
	return 0
}

func (m *LatestETH1Data) GetBlockTime() uint64 {
	if m != nil {
		return m.BlockTime
	}
	return 0
}

func (m *LatestETH1Data) GetBlockHash() [][]byte {
	if m != nil {
		return m.BlockHash
	}
	return nil
}

func (m *LatestETH1Data) GetLastRequestedBlock() uint64 {
	if m != nil {
		return m.LastRequestedBlock
	}
	return 0
}

type ChainStartData struct {
	Chainstarted         bool                `protobuf:"varint,1,opt,name=chainstarted,proto3" json:"chainstarted,omitempty"`
	GenesisTime          uint64              `protobuf:"varint,2,opt,name=genesis_time,json=genesisTime,proto3" json:"genesis_time,omitempty"`
	GenesisBlock         uint64              `protobuf:"varint,3,opt,name=genesis_block,json=genesisBlock,proto3" json:"genesis_block,omitempty"`
	Eth1Data             *v1alpha1.Eth1Data  `protobuf:"bytes,4,opt,name=eth1_data,json=eth1Data,proto3" json:"eth1_data,omitempty"`
	ChainstartDeposits   []*v1alpha1.Deposit `protobuf:"bytes,5,rep,name=chainstart_deposits,json=chainstartDeposits,proto3" json:"chainstart_deposits,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *ChainStartData) Reset()         { *m = ChainStartData{} }
func (m *ChainStartData) String() string { return proto.CompactTextString(m) }
func (*ChainStartData) ProtoMessage()    {}
func (*ChainStartData) Descriptor() ([]byte, []int) {
	return fileDescriptor_338787f8da2f3d61, []int{2}
}
func (m *ChainStartData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChainStartData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChainStartData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ChainStartData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChainStartData.Merge(m, src)
}
func (m *ChainStartData) XXX_Size() int {
	return m.Size()
}
func (m *ChainStartData) XXX_DiscardUnknown() {
	xxx_messageInfo_ChainStartData.DiscardUnknown(m)
}

var xxx_messageInfo_ChainStartData proto.InternalMessageInfo

func (m *ChainStartData) GetChainstarted() bool {
	if m != nil {
		return m.Chainstarted
	}
	return false
}

func (m *ChainStartData) GetGenesisTime() uint64 {
	if m != nil {
		return m.GenesisTime
	}
	return 0
}

func (m *ChainStartData) GetGenesisBlock() uint64 {
	if m != nil {
		return m.GenesisBlock
	}
	return 0
}

func (m *ChainStartData) GetEth1Data() *v1alpha1.Eth1Data {
	if m != nil {
		return m.Eth1Data
	}
	return nil
}

func (m *ChainStartData) GetChainstartDeposits() []*v1alpha1.Deposit {
	if m != nil {
		return m.ChainstartDeposits
	}
	return nil
}

type SparseMerkleTrie struct {
	Depth                uint64       `protobuf:"varint,1,opt,name=depth,proto3" json:"depth,omitempty"`
	Layers               []*TrieLayer `protobuf:"bytes,2,rep,name=layers,proto3" json:"layers,omitempty"`
	OriginalItems        [][]byte     `protobuf:"bytes,3,rep,name=original_items,json=originalItems,proto3" json:"original_items,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *SparseMerkleTrie) Reset()         { *m = SparseMerkleTrie{} }
func (m *SparseMerkleTrie) String() string { return proto.CompactTextString(m) }
func (*SparseMerkleTrie) ProtoMessage()    {}
func (*SparseMerkleTrie) Descriptor() ([]byte, []int) {
	return fileDescriptor_338787f8da2f3d61, []int{3}
}
func (m *SparseMerkleTrie) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SparseMerkleTrie) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SparseMerkleTrie.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SparseMerkleTrie) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SparseMerkleTrie.Merge(m, src)
}
func (m *SparseMerkleTrie) XXX_Size() int {
	return m.Size()
}
func (m *SparseMerkleTrie) XXX_DiscardUnknown() {
	xxx_messageInfo_SparseMerkleTrie.DiscardUnknown(m)
}

var xxx_messageInfo_SparseMerkleTrie proto.InternalMessageInfo

func (m *SparseMerkleTrie) GetDepth() uint64 {
	if m != nil {
		return m.Depth
	}
	return 0
}

func (m *SparseMerkleTrie) GetLayers() []*TrieLayer {
	if m != nil {
		return m.Layers
	}
	return nil
}

func (m *SparseMerkleTrie) GetOriginalItems() [][]byte {
	if m != nil {
		return m.OriginalItems
	}
	return nil
}

type TrieLayer struct {
	Layer                [][]byte `protobuf:"bytes,1,rep,name=layer,proto3" json:"layer,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TrieLayer) Reset()         { *m = TrieLayer{} }
func (m *TrieLayer) String() string { return proto.CompactTextString(m) }
func (*TrieLayer) ProtoMessage()    {}
func (*TrieLayer) Descriptor() ([]byte, []int) {
	return fileDescriptor_338787f8da2f3d61, []int{4}
}
func (m *TrieLayer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TrieLayer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TrieLayer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TrieLayer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TrieLayer.Merge(m, src)
}
func (m *TrieLayer) XXX_Size() int {
	return m.Size()
}
func (m *TrieLayer) XXX_DiscardUnknown() {
	xxx_messageInfo_TrieLayer.DiscardUnknown(m)
}

var xxx_messageInfo_TrieLayer proto.InternalMessageInfo

func (m *TrieLayer) GetLayer() [][]byte {
	if m != nil {
		return m.Layer
	}
	return nil
}

func init() {
	proto.RegisterType((*ETH1ChainData)(nil), "prysm.beacon.db.ETH1ChainData")
	proto.RegisterType((*LatestETH1Data)(nil), "prysm.beacon.db.LatestETH1Data")
	proto.RegisterType((*ChainStartData)(nil), "prysm.beacon.db.ChainStartData")
	proto.RegisterType((*SparseMerkleTrie)(nil), "prysm.beacon.db.SparseMerkleTrie")
	proto.RegisterType((*TrieLayer)(nil), "prysm.beacon.db.TrieLayer")
}

func init() { proto.RegisterFile("proto/beacon/db/powchain.proto", fileDescriptor_338787f8da2f3d61) }

var fileDescriptor_338787f8da2f3d61 = []byte{
	// 577 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x74, 0x54, 0xcd, 0x4e, 0x1b, 0x3d,
	0x14, 0xd5, 0x24, 0x03, 0x02, 0x27, 0x84, 0xef, 0x73, 0x59, 0x8c, 0x90, 0x1a, 0x20, 0xa8, 0x12,
	0x2b, 0x4f, 0x93, 0xaa, 0x3b, 0x56, 0x14, 0xaa, 0x54, 0xa5, 0xaa, 0x34, 0xb0, 0xea, 0x26, 0xf2,
	0x24, 0x57, 0xb1, 0xc5, 0x24, 0xe3, 0xda, 0x37, 0x54, 0xac, 0xbb, 0xec, 0x63, 0x54, 0x7d, 0x97,
	0x2e, 0xfb, 0x08, 0x15, 0x4f, 0x52, 0xf9, 0x7a, 0x86, 0x90, 0x20, 0x96, 0xf7, 0xdc, 0x73, 0x8e,
	0xef, 0x9f, 0xcc, 0xba, 0xc6, 0x96, 0x58, 0xa6, 0x39, 0xc8, 0x71, 0x39, 0x4f, 0x27, 0x79, 0x6a,
	0xca, 0x6f, 0x63, 0x25, 0xf5, 0x5c, 0x50, 0x82, 0xef, 0x1a, 0x7b, 0xe7, 0x66, 0x22, 0xe4, 0xc5,
	0x24, 0xdf, 0x3f, 0x00, 0x54, 0xe9, 0x6d, 0x5f, 0x16, 0x46, 0xc9, 0x7e, 0xa5, 0x1b, 0xe5, 0x45,
	0x39, 0xbe, 0x09, 0x8a, 0xfd, 0x83, 0x15, 0x47, 0x33, 0x30, 0xe9, 0x6d, 0x3f, 0xc5, 0x3b, 0x03,
	0x2e, 0x10, 0x7a, 0xbf, 0x1a, 0x6c, 0xe7, 0xe2, 0x7a, 0xd8, 0x7f, 0xe7, 0x9f, 0x39, 0x97, 0x28,
	0xf9, 0x47, 0xf6, 0xff, 0x78, 0x61, 0x2d, 0xcc, 0x71, 0x04, 0xa8, 0xfa, 0xa3, 0x89, 0x44, 0x99,
	0x44, 0x87, 0xd1, 0x49, 0x6b, 0x70, 0x20, 0xd6, 0x0a, 0x10, 0x97, 0x12, 0xc1, 0xa1, 0x37, 0xf0,
	0xda, 0x6c, 0xb7, 0x52, 0x5e, 0xa0, 0x22, 0x80, 0x0f, 0xd9, 0x2e, 0x35, 0xe0, 0x50, 0x5a, 0x0c,
	0x56, 0x8d, 0x67, 0xac, 0xa8, 0x82, 0x2b, 0xcf, 0x23, 0xab, 0xce, 0x52, 0x47, 0x4e, 0xef, 0x59,
	0xbb, 0xea, 0xcf, 0xa1, 0x44, 0x48, 0x9a, 0x64, 0x73, 0x2c, 0x00, 0x15, 0x58, 0x58, 0x3c, 0x38,
	0x99, 0x81, 0x11, 0xb7, 0x7d, 0x71, 0x46, 0xd1, 0x95, 0xa7, 0x66, 0xad, 0x7c, 0x19, 0xf0, 0xb7,
	0x2c, 0x46, 0xab, 0x21, 0x89, 0x49, 0x7f, 0xf4, 0xa4, 0x8c, 0x2b, 0x23, 0xad, 0x83, 0x4f, 0x60,
	0x6f, 0x0a, 0xb8, 0xb6, 0x1a, 0x32, 0xa2, 0xf7, 0x7e, 0x46, 0xac, 0xb3, 0xda, 0x2c, 0x3f, 0x62,
	0x6d, 0x1a, 0xf5, 0x48, 0x81, 0x9e, 0x2a, 0xa4, 0xc6, 0xe2, 0xac, 0x45, 0xd8, 0x90, 0x20, 0xfe,
	0x92, 0xb1, 0x40, 0x41, 0x3d, 0x0b, 0x25, 0xc7, 0xd9, 0x36, 0x21, 0xd7, 0x7a, 0x06, 0xcb, 0xb4,
	0x92, 0x4e, 0x25, 0xf1, 0x61, 0xf3, 0xa4, 0x5d, 0xa5, 0x87, 0xd2, 0x29, 0xfe, 0x9a, 0xed, 0x15,
	0xd2, 0xe1, 0xc8, 0xc2, 0xd7, 0x05, 0x38, 0x84, 0x49, 0x58, 0x6d, 0xb2, 0x41, 0x3e, 0xdc, 0xe7,
	0xb2, 0x3a, 0x75, 0xe6, 0x33, 0xbd, 0x1f, 0x0d, 0xd6, 0x59, 0x9d, 0x23, 0xef, 0xb1, 0xf6, 0x72,
	0x92, 0x30, 0xa1, 0x4d, 0x6e, 0x65, 0x2b, 0x98, 0xef, 0x64, 0x0a, 0x73, 0x70, 0xda, 0x85, 0x42,
	0xab, 0x4e, 0x2a, 0x8c, 0x4a, 0x3d, 0x66, 0x3b, 0x35, 0x25, 0x14, 0x11, 0x9a, 0xa9, 0x75, 0xf4,
	0x3c, 0x3f, 0x65, 0xdb, 0xcb, 0x93, 0x89, 0xab, 0x3d, 0x3f, 0x2c, 0x08, 0x50, 0x89, 0xfa, 0x56,
	0x45, 0x7d, 0x21, 0xd9, 0x16, 0xd4, 0xb7, 0xf2, 0x99, 0xbd, 0x78, 0x7c, 0x2b, 0x60, 0x4a, 0xa7,
	0xd1, 0x25, 0x1b, 0x87, 0xcd, 0x93, 0xd6, 0xa0, 0xfb, 0x8c, 0xcf, 0x79, 0xa0, 0x65, 0xfc, 0xd1,
	0xb9, 0x54, 0xca, 0xde, 0xf7, 0x88, 0xfd, 0xb7, 0xbe, 0x4e, 0xbe, 0xc7, 0x36, 0x26, 0x60, 0x50,
	0xd1, 0x20, 0xe2, 0x2c, 0x04, 0x7c, 0xc0, 0x36, 0x0b, 0x79, 0x07, 0xd6, 0x25, 0x0d, 0x7a, 0x6e,
	0xff, 0xc9, 0x5d, 0x78, 0xf1, 0xa5, 0xa7, 0x64, 0x15, 0x93, 0xbf, 0x62, 0x9d, 0xd2, 0xea, 0xa9,
	0x9e, 0xcb, 0x62, 0xa4, 0x11, 0x66, 0x2e, 0x69, 0xd2, 0x06, 0x77, 0x6a, 0xf4, 0x83, 0x07, 0x7b,
	0x47, 0x6c, 0xfb, 0x41, 0xeb, 0x5f, 0x27, 0x75, 0x12, 0x11, 0x35, 0x04, 0x67, 0xa7, 0xbf, 0xef,
	0xbb, 0xd1, 0x9f, 0xfb, 0x6e, 0xf4, 0xf7, 0xbe, 0x1b, 0x7d, 0x11, 0x53, 0x8d, 0x6a, 0x91, 0x8b,
	0x71, 0x39, 0x4b, 0xa9, 0x0a, 0x89, 0x7a, 0x5c, 0xc8, 0xdc, 0x85, 0x28, 0x5d, 0xfb, 0x24, 0xf2,
	0x4d, 0x02, 0xde, 0xfc, 0x0b, 0x00, 0x00, 0xff, 0xff, 0x4b, 0xc3, 0xeb, 0x56, 0x3e, 0x04, 0x00,
	0x00,
}

func (m *ETH1ChainData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ETH1ChainData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ETH1ChainData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Trie != nil {
		{
			size, err := m.Trie.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPowchain(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.BeaconState != nil {
		{
			size, err := m.BeaconState.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPowchain(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.ChainstartData != nil {
		{
			size, err := m.ChainstartData.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPowchain(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.CurrentEth1Data != nil {
		{
			size, err := m.CurrentEth1Data.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPowchain(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LatestETH1Data) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LatestETH1Data) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LatestETH1Data) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.LastRequestedBlock != 0 {
		i = encodeVarintPowchain(dAtA, i, uint64(m.LastRequestedBlock))
		i--
		dAtA[i] = 0x28
	}
	if len(m.BlockHash) > 0 {
		for iNdEx := len(m.BlockHash) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.BlockHash[iNdEx])
			copy(dAtA[i:], m.BlockHash[iNdEx])
			i = encodeVarintPowchain(dAtA, i, uint64(len(m.BlockHash[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if m.BlockTime != 0 {
		i = encodeVarintPowchain(dAtA, i, uint64(m.BlockTime))
		i--
		dAtA[i] = 0x18
	}
	if m.BlockHeight != 0 {
		i = encodeVarintPowchain(dAtA, i, uint64(m.BlockHeight))
		i--
		dAtA[i] = 0x10
	}
	return len(dAtA) - i, nil
}

func (m *ChainStartData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChainStartData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChainStartData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ChainstartDeposits) > 0 {
		for iNdEx := len(m.ChainstartDeposits) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ChainstartDeposits[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPowchain(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.Eth1Data != nil {
		{
			size, err := m.Eth1Data.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPowchain(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.GenesisBlock != 0 {
		i = encodeVarintPowchain(dAtA, i, uint64(m.GenesisBlock))
		i--
		dAtA[i] = 0x18
	}
	if m.GenesisTime != 0 {
		i = encodeVarintPowchain(dAtA, i, uint64(m.GenesisTime))
		i--
		dAtA[i] = 0x10
	}
	if m.Chainstarted {
		i--
		if m.Chainstarted {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SparseMerkleTrie) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SparseMerkleTrie) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SparseMerkleTrie) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.OriginalItems) > 0 {
		for iNdEx := len(m.OriginalItems) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.OriginalItems[iNdEx])
			copy(dAtA[i:], m.OriginalItems[iNdEx])
			i = encodeVarintPowchain(dAtA, i, uint64(len(m.OriginalItems[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Layers) > 0 {
		for iNdEx := len(m.Layers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Layers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPowchain(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Depth != 0 {
		i = encodeVarintPowchain(dAtA, i, uint64(m.Depth))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TrieLayer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TrieLayer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TrieLayer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Layer) > 0 {
		for iNdEx := len(m.Layer) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Layer[iNdEx])
			copy(dAtA[i:], m.Layer[iNdEx])
			i = encodeVarintPowchain(dAtA, i, uint64(len(m.Layer[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintPowchain(dAtA []byte, offset int, v uint64) int {
	offset -= sovPowchain(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ETH1ChainData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CurrentEth1Data != nil {
		l = m.CurrentEth1Data.Size()
		n += 1 + l + sovPowchain(uint64(l))
	}
	if m.ChainstartData != nil {
		l = m.ChainstartData.Size()
		n += 1 + l + sovPowchain(uint64(l))
	}
	if m.BeaconState != nil {
		l = m.BeaconState.Size()
		n += 1 + l + sovPowchain(uint64(l))
	}
	if m.Trie != nil {
		l = m.Trie.Size()
		n += 1 + l + sovPowchain(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LatestETH1Data) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BlockHeight != 0 {
		n += 1 + sovPowchain(uint64(m.BlockHeight))
	}
	if m.BlockTime != 0 {
		n += 1 + sovPowchain(uint64(m.BlockTime))
	}
	if len(m.BlockHash) > 0 {
		for _, b := range m.BlockHash {
			l = len(b)
			n += 1 + l + sovPowchain(uint64(l))
		}
	}
	if m.LastRequestedBlock != 0 {
		n += 1 + sovPowchain(uint64(m.LastRequestedBlock))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ChainStartData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Chainstarted {
		n += 2
	}
	if m.GenesisTime != 0 {
		n += 1 + sovPowchain(uint64(m.GenesisTime))
	}
	if m.GenesisBlock != 0 {
		n += 1 + sovPowchain(uint64(m.GenesisBlock))
	}
	if m.Eth1Data != nil {
		l = m.Eth1Data.Size()
		n += 1 + l + sovPowchain(uint64(l))
	}
	if len(m.ChainstartDeposits) > 0 {
		for _, e := range m.ChainstartDeposits {
			l = e.Size()
			n += 1 + l + sovPowchain(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SparseMerkleTrie) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Depth != 0 {
		n += 1 + sovPowchain(uint64(m.Depth))
	}
	if len(m.Layers) > 0 {
		for _, e := range m.Layers {
			l = e.Size()
			n += 1 + l + sovPowchain(uint64(l))
		}
	}
	if len(m.OriginalItems) > 0 {
		for _, b := range m.OriginalItems {
			l = len(b)
			n += 1 + l + sovPowchain(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TrieLayer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Layer) > 0 {
		for _, b := range m.Layer {
			l = len(b)
			n += 1 + l + sovPowchain(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovPowchain(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozPowchain(x uint64) (n int) {
	return sovPowchain(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ETH1ChainData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPowchain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ETH1ChainData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ETH1ChainData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentEth1Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPowchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPowchain
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPowchain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CurrentEth1Data == nil {
				m.CurrentEth1Data = &LatestETH1Data{}
			}
			if err := m.CurrentEth1Data.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainstartData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPowchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPowchain
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPowchain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ChainstartData == nil {
				m.ChainstartData = &ChainStartData{}
			}
			if err := m.ChainstartData.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BeaconState", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPowchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPowchain
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPowchain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BeaconState == nil {
				m.BeaconState = &v1.BeaconState{}
			}
			if err := m.BeaconState.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Trie", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPowchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPowchain
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPowchain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Trie == nil {
				m.Trie = &SparseMerkleTrie{}
			}
			if err := m.Trie.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPowchain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPowchain
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPowchain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LatestETH1Data) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPowchain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LatestETH1Data: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LatestETH1Data: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockHeight", wireType)
			}
			m.BlockHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPowchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockHeight |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockTime", wireType)
			}
			m.BlockTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPowchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockTime |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPowchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPowchain
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPowchain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BlockHash = append(m.BlockHash, make([]byte, postIndex-iNdEx))
			copy(m.BlockHash[len(m.BlockHash)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastRequestedBlock", wireType)
			}
			m.LastRequestedBlock = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPowchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastRequestedBlock |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPowchain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPowchain
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPowchain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChainStartData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPowchain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChainStartData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChainStartData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chainstarted", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPowchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Chainstarted = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GenesisTime", wireType)
			}
			m.GenesisTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPowchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GenesisTime |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GenesisBlock", wireType)
			}
			m.GenesisBlock = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPowchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GenesisBlock |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Eth1Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPowchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPowchain
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPowchain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Eth1Data == nil {
				m.Eth1Data = &v1alpha1.Eth1Data{}
			}
			if err := m.Eth1Data.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainstartDeposits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPowchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPowchain
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPowchain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainstartDeposits = append(m.ChainstartDeposits, &v1alpha1.Deposit{})
			if err := m.ChainstartDeposits[len(m.ChainstartDeposits)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPowchain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPowchain
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPowchain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SparseMerkleTrie) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPowchain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SparseMerkleTrie: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SparseMerkleTrie: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Depth", wireType)
			}
			m.Depth = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPowchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Depth |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Layers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPowchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPowchain
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPowchain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Layers = append(m.Layers, &TrieLayer{})
			if err := m.Layers[len(m.Layers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginalItems", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPowchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPowchain
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPowchain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OriginalItems = append(m.OriginalItems, make([]byte, postIndex-iNdEx))
			copy(m.OriginalItems[len(m.OriginalItems)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPowchain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPowchain
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPowchain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TrieLayer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPowchain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TrieLayer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TrieLayer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Layer", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPowchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPowchain
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPowchain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Layer = append(m.Layer, make([]byte, postIndex-iNdEx))
			copy(m.Layer[len(m.Layer)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPowchain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPowchain
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPowchain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipPowchain(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowPowchain
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPowchain
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPowchain
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthPowchain
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthPowchain
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowPowchain
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipPowchain(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthPowchain
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthPowchain = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowPowchain   = fmt.Errorf("proto: integer overflow")
)
