// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: proto/eth/v1alpha1/beacon_chain.proto

package eth

import (
	context "context"
	encoding_binary "encoding/binary"
	fmt "fmt"
	io "io"
	math "math"

	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	types "github.com/gogo/protobuf/types"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type ListAttestationsRequest struct {
	// Types that are valid to be assigned to QueryFilter:
	//	*ListAttestationsRequest_HeadBlockRoot
	//	*ListAttestationsRequest_SourceEpoch
	//	*ListAttestationsRequest_SourceRoot
	//	*ListAttestationsRequest_TargetEpoch
	//	*ListAttestationsRequest_TargetRoot
	QueryFilter          isListAttestationsRequest_QueryFilter `protobuf_oneof:"query_filter"`
	PageSize             int32                                 `protobuf:"varint,6,opt,name=page_size,json=pageSize,proto3" json:"page_size,omitempty"`
	PageToken            string                                `protobuf:"bytes,7,opt,name=page_token,json=pageToken,proto3" json:"page_token,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                              `json:"-"`
	XXX_unrecognized     []byte                                `json:"-"`
	XXX_sizecache        int32                                 `json:"-"`
}

func (m *ListAttestationsRequest) Reset()         { *m = ListAttestationsRequest{} }
func (m *ListAttestationsRequest) String() string { return proto.CompactTextString(m) }
func (*ListAttestationsRequest) ProtoMessage()    {}
func (*ListAttestationsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_678c88b69c3c78d4, []int{0}
}
func (m *ListAttestationsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListAttestationsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListAttestationsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListAttestationsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListAttestationsRequest.Merge(m, src)
}
func (m *ListAttestationsRequest) XXX_Size() int {
	return m.Size()
}
func (m *ListAttestationsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListAttestationsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListAttestationsRequest proto.InternalMessageInfo

type isListAttestationsRequest_QueryFilter interface {
	isListAttestationsRequest_QueryFilter()
	MarshalTo([]byte) (int, error)
	Size() int
}

type ListAttestationsRequest_HeadBlockRoot struct {
	HeadBlockRoot []byte `protobuf:"bytes,1,opt,name=head_block_root,json=headBlockRoot,proto3,oneof"`
}
type ListAttestationsRequest_SourceEpoch struct {
	SourceEpoch uint64 `protobuf:"varint,2,opt,name=source_epoch,json=sourceEpoch,proto3,oneof"`
}
type ListAttestationsRequest_SourceRoot struct {
	SourceRoot []byte `protobuf:"bytes,3,opt,name=source_root,json=sourceRoot,proto3,oneof"`
}
type ListAttestationsRequest_TargetEpoch struct {
	TargetEpoch uint64 `protobuf:"varint,4,opt,name=target_epoch,json=targetEpoch,proto3,oneof"`
}
type ListAttestationsRequest_TargetRoot struct {
	TargetRoot []byte `protobuf:"bytes,5,opt,name=target_root,json=targetRoot,proto3,oneof"`
}

func (*ListAttestationsRequest_HeadBlockRoot) isListAttestationsRequest_QueryFilter() {}
func (*ListAttestationsRequest_SourceEpoch) isListAttestationsRequest_QueryFilter()   {}
func (*ListAttestationsRequest_SourceRoot) isListAttestationsRequest_QueryFilter()    {}
func (*ListAttestationsRequest_TargetEpoch) isListAttestationsRequest_QueryFilter()   {}
func (*ListAttestationsRequest_TargetRoot) isListAttestationsRequest_QueryFilter()    {}

func (m *ListAttestationsRequest) GetQueryFilter() isListAttestationsRequest_QueryFilter {
	if m != nil {
		return m.QueryFilter
	}
	return nil
}

func (m *ListAttestationsRequest) GetHeadBlockRoot() []byte {
	if x, ok := m.GetQueryFilter().(*ListAttestationsRequest_HeadBlockRoot); ok {
		return x.HeadBlockRoot
	}
	return nil
}

func (m *ListAttestationsRequest) GetSourceEpoch() uint64 {
	if x, ok := m.GetQueryFilter().(*ListAttestationsRequest_SourceEpoch); ok {
		return x.SourceEpoch
	}
	return 0
}

func (m *ListAttestationsRequest) GetSourceRoot() []byte {
	if x, ok := m.GetQueryFilter().(*ListAttestationsRequest_SourceRoot); ok {
		return x.SourceRoot
	}
	return nil
}

func (m *ListAttestationsRequest) GetTargetEpoch() uint64 {
	if x, ok := m.GetQueryFilter().(*ListAttestationsRequest_TargetEpoch); ok {
		return x.TargetEpoch
	}
	return 0
}

func (m *ListAttestationsRequest) GetTargetRoot() []byte {
	if x, ok := m.GetQueryFilter().(*ListAttestationsRequest_TargetRoot); ok {
		return x.TargetRoot
	}
	return nil
}

func (m *ListAttestationsRequest) GetPageSize() int32 {
	if m != nil {
		return m.PageSize
	}
	return 0
}

func (m *ListAttestationsRequest) GetPageToken() string {
	if m != nil {
		return m.PageToken
	}
	return ""
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ListAttestationsRequest) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ListAttestationsRequest_OneofMarshaler, _ListAttestationsRequest_OneofUnmarshaler, _ListAttestationsRequest_OneofSizer, []interface{}{
		(*ListAttestationsRequest_HeadBlockRoot)(nil),
		(*ListAttestationsRequest_SourceEpoch)(nil),
		(*ListAttestationsRequest_SourceRoot)(nil),
		(*ListAttestationsRequest_TargetEpoch)(nil),
		(*ListAttestationsRequest_TargetRoot)(nil),
	}
}

func _ListAttestationsRequest_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ListAttestationsRequest)
	// query_filter
	switch x := m.QueryFilter.(type) {
	case *ListAttestationsRequest_HeadBlockRoot:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		_ = b.EncodeRawBytes(x.HeadBlockRoot)
	case *ListAttestationsRequest_SourceEpoch:
		_ = b.EncodeVarint(2<<3 | proto.WireVarint)
		_ = b.EncodeVarint(uint64(x.SourceEpoch))
	case *ListAttestationsRequest_SourceRoot:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		_ = b.EncodeRawBytes(x.SourceRoot)
	case *ListAttestationsRequest_TargetEpoch:
		_ = b.EncodeVarint(4<<3 | proto.WireVarint)
		_ = b.EncodeVarint(uint64(x.TargetEpoch))
	case *ListAttestationsRequest_TargetRoot:
		_ = b.EncodeVarint(5<<3 | proto.WireBytes)
		_ = b.EncodeRawBytes(x.TargetRoot)
	case nil:
	default:
		return fmt.Errorf("ListAttestationsRequest.QueryFilter has unexpected type %T", x)
	}
	return nil
}

func _ListAttestationsRequest_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ListAttestationsRequest)
	switch tag {
	case 1: // query_filter.head_block_root
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeRawBytes(true)
		m.QueryFilter = &ListAttestationsRequest_HeadBlockRoot{x}
		return true, err
	case 2: // query_filter.source_epoch
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.QueryFilter = &ListAttestationsRequest_SourceEpoch{x}
		return true, err
	case 3: // query_filter.source_root
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeRawBytes(true)
		m.QueryFilter = &ListAttestationsRequest_SourceRoot{x}
		return true, err
	case 4: // query_filter.target_epoch
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.QueryFilter = &ListAttestationsRequest_TargetEpoch{x}
		return true, err
	case 5: // query_filter.target_root
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeRawBytes(true)
		m.QueryFilter = &ListAttestationsRequest_TargetRoot{x}
		return true, err
	default:
		return false, nil
	}
}

func _ListAttestationsRequest_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ListAttestationsRequest)
	// query_filter
	switch x := m.QueryFilter.(type) {
	case *ListAttestationsRequest_HeadBlockRoot:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(len(x.HeadBlockRoot)))
		n += len(x.HeadBlockRoot)
	case *ListAttestationsRequest_SourceEpoch:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(x.SourceEpoch))
	case *ListAttestationsRequest_SourceRoot:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(len(x.SourceRoot)))
		n += len(x.SourceRoot)
	case *ListAttestationsRequest_TargetEpoch:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(x.TargetEpoch))
	case *ListAttestationsRequest_TargetRoot:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(len(x.TargetRoot)))
		n += len(x.TargetRoot)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type ListAttestationsResponse struct {
	Attestations         []*Attestation `protobuf:"bytes,1,rep,name=attestations,proto3" json:"attestations,omitempty"`
	NextPageToken        string         `protobuf:"bytes,2,opt,name=next_page_token,json=nextPageToken,proto3" json:"next_page_token,omitempty"`
	TotalSize            int32          `protobuf:"varint,3,opt,name=total_size,json=totalSize,proto3" json:"total_size,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *ListAttestationsResponse) Reset()         { *m = ListAttestationsResponse{} }
func (m *ListAttestationsResponse) String() string { return proto.CompactTextString(m) }
func (*ListAttestationsResponse) ProtoMessage()    {}
func (*ListAttestationsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_678c88b69c3c78d4, []int{1}
}
func (m *ListAttestationsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListAttestationsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListAttestationsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListAttestationsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListAttestationsResponse.Merge(m, src)
}
func (m *ListAttestationsResponse) XXX_Size() int {
	return m.Size()
}
func (m *ListAttestationsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListAttestationsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListAttestationsResponse proto.InternalMessageInfo

func (m *ListAttestationsResponse) GetAttestations() []*Attestation {
	if m != nil {
		return m.Attestations
	}
	return nil
}

func (m *ListAttestationsResponse) GetNextPageToken() string {
	if m != nil {
		return m.NextPageToken
	}
	return ""
}

func (m *ListAttestationsResponse) GetTotalSize() int32 {
	if m != nil {
		return m.TotalSize
	}
	return 0
}

type ListBlocksRequest struct {
	// Types that are valid to be assigned to QueryFilter:
	//	*ListBlocksRequest_Root
	//	*ListBlocksRequest_Slot
	//	*ListBlocksRequest_Epoch
	QueryFilter          isListBlocksRequest_QueryFilter `protobuf_oneof:"query_filter"`
	IncludeNoncanonical  bool                            `protobuf:"varint,4,opt,name=include_noncanonical,json=includeNoncanonical,proto3" json:"include_noncanonical,omitempty"`
	PageSize             int32                           `protobuf:"varint,5,opt,name=page_size,json=pageSize,proto3" json:"page_size,omitempty"`
	PageToken            string                          `protobuf:"bytes,6,opt,name=page_token,json=pageToken,proto3" json:"page_token,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                        `json:"-"`
	XXX_unrecognized     []byte                          `json:"-"`
	XXX_sizecache        int32                           `json:"-"`
}

func (m *ListBlocksRequest) Reset()         { *m = ListBlocksRequest{} }
func (m *ListBlocksRequest) String() string { return proto.CompactTextString(m) }
func (*ListBlocksRequest) ProtoMessage()    {}
func (*ListBlocksRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_678c88b69c3c78d4, []int{2}
}
func (m *ListBlocksRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListBlocksRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListBlocksRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListBlocksRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListBlocksRequest.Merge(m, src)
}
func (m *ListBlocksRequest) XXX_Size() int {
	return m.Size()
}
func (m *ListBlocksRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListBlocksRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListBlocksRequest proto.InternalMessageInfo

type isListBlocksRequest_QueryFilter interface {
	isListBlocksRequest_QueryFilter()
	MarshalTo([]byte) (int, error)
	Size() int
}

type ListBlocksRequest_Root struct {
	Root []byte `protobuf:"bytes,1,opt,name=root,proto3,oneof"`
}
type ListBlocksRequest_Slot struct {
	Slot uint64 `protobuf:"varint,2,opt,name=slot,proto3,oneof"`
}
type ListBlocksRequest_Epoch struct {
	Epoch uint64 `protobuf:"varint,3,opt,name=epoch,proto3,oneof"`
}

func (*ListBlocksRequest_Root) isListBlocksRequest_QueryFilter()  {}
func (*ListBlocksRequest_Slot) isListBlocksRequest_QueryFilter()  {}
func (*ListBlocksRequest_Epoch) isListBlocksRequest_QueryFilter() {}

func (m *ListBlocksRequest) GetQueryFilter() isListBlocksRequest_QueryFilter {
	if m != nil {
		return m.QueryFilter
	}
	return nil
}

func (m *ListBlocksRequest) GetRoot() []byte {
	if x, ok := m.GetQueryFilter().(*ListBlocksRequest_Root); ok {
		return x.Root
	}
	return nil
}

func (m *ListBlocksRequest) GetSlot() uint64 {
	if x, ok := m.GetQueryFilter().(*ListBlocksRequest_Slot); ok {
		return x.Slot
	}
	return 0
}

func (m *ListBlocksRequest) GetEpoch() uint64 {
	if x, ok := m.GetQueryFilter().(*ListBlocksRequest_Epoch); ok {
		return x.Epoch
	}
	return 0
}

func (m *ListBlocksRequest) GetIncludeNoncanonical() bool {
	if m != nil {
		return m.IncludeNoncanonical
	}
	return false
}

func (m *ListBlocksRequest) GetPageSize() int32 {
	if m != nil {
		return m.PageSize
	}
	return 0
}

func (m *ListBlocksRequest) GetPageToken() string {
	if m != nil {
		return m.PageToken
	}
	return ""
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ListBlocksRequest) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ListBlocksRequest_OneofMarshaler, _ListBlocksRequest_OneofUnmarshaler, _ListBlocksRequest_OneofSizer, []interface{}{
		(*ListBlocksRequest_Root)(nil),
		(*ListBlocksRequest_Slot)(nil),
		(*ListBlocksRequest_Epoch)(nil),
	}
}

func _ListBlocksRequest_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ListBlocksRequest)
	// query_filter
	switch x := m.QueryFilter.(type) {
	case *ListBlocksRequest_Root:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		_ = b.EncodeRawBytes(x.Root)
	case *ListBlocksRequest_Slot:
		_ = b.EncodeVarint(2<<3 | proto.WireVarint)
		_ = b.EncodeVarint(uint64(x.Slot))
	case *ListBlocksRequest_Epoch:
		_ = b.EncodeVarint(3<<3 | proto.WireVarint)
		_ = b.EncodeVarint(uint64(x.Epoch))
	case nil:
	default:
		return fmt.Errorf("ListBlocksRequest.QueryFilter has unexpected type %T", x)
	}
	return nil
}

func _ListBlocksRequest_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ListBlocksRequest)
	switch tag {
	case 1: // query_filter.root
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeRawBytes(true)
		m.QueryFilter = &ListBlocksRequest_Root{x}
		return true, err
	case 2: // query_filter.slot
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.QueryFilter = &ListBlocksRequest_Slot{x}
		return true, err
	case 3: // query_filter.epoch
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.QueryFilter = &ListBlocksRequest_Epoch{x}
		return true, err
	default:
		return false, nil
	}
}

func _ListBlocksRequest_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ListBlocksRequest)
	// query_filter
	switch x := m.QueryFilter.(type) {
	case *ListBlocksRequest_Root:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(len(x.Root)))
		n += len(x.Root)
	case *ListBlocksRequest_Slot:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(x.Slot))
	case *ListBlocksRequest_Epoch:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(x.Epoch))
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type ListBlocksResponse struct {
	Blocks               []*BeaconBlock `protobuf:"bytes,1,rep,name=blocks,proto3" json:"blocks,omitempty"`
	NextPageToken        string         `protobuf:"bytes,2,opt,name=next_page_token,json=nextPageToken,proto3" json:"next_page_token,omitempty"`
	TotalSize            int32          `protobuf:"varint,3,opt,name=total_size,json=totalSize,proto3" json:"total_size,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *ListBlocksResponse) Reset()         { *m = ListBlocksResponse{} }
func (m *ListBlocksResponse) String() string { return proto.CompactTextString(m) }
func (*ListBlocksResponse) ProtoMessage()    {}
func (*ListBlocksResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_678c88b69c3c78d4, []int{3}
}
func (m *ListBlocksResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListBlocksResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListBlocksResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListBlocksResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListBlocksResponse.Merge(m, src)
}
func (m *ListBlocksResponse) XXX_Size() int {
	return m.Size()
}
func (m *ListBlocksResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListBlocksResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListBlocksResponse proto.InternalMessageInfo

func (m *ListBlocksResponse) GetBlocks() []*BeaconBlock {
	if m != nil {
		return m.Blocks
	}
	return nil
}

func (m *ListBlocksResponse) GetNextPageToken() string {
	if m != nil {
		return m.NextPageToken
	}
	return ""
}

func (m *ListBlocksResponse) GetTotalSize() int32 {
	if m != nil {
		return m.TotalSize
	}
	return 0
}

type ChainHead struct {
	BlockRoot                  []byte   `protobuf:"bytes,1,opt,name=block_root,json=blockRoot,proto3" json:"block_root,omitempty" ssz-size:"32"`
	BlockSlot                  uint64   `protobuf:"varint,2,opt,name=block_slot,json=blockSlot,proto3" json:"block_slot,omitempty"`
	FinalizedSlot              uint64   `protobuf:"varint,3,opt,name=finalized_slot,json=finalizedSlot,proto3" json:"finalized_slot,omitempty"`
	FinalizedBlockRoot         []byte   `protobuf:"bytes,4,opt,name=finalized_block_root,json=finalizedBlockRoot,proto3" json:"finalized_block_root,omitempty" ssz-size:"32"`
	JustifiedSlot              uint64   `protobuf:"varint,5,opt,name=justified_slot,json=justifiedSlot,proto3" json:"justified_slot,omitempty"`
	JustifiedBlockRoot         []byte   `protobuf:"bytes,6,opt,name=justified_block_root,json=justifiedBlockRoot,proto3" json:"justified_block_root,omitempty" ssz-size:"32"`
	PreviousJustifiedSlot      uint64   `protobuf:"varint,7,opt,name=previous_justified_slot,json=previousJustifiedSlot,proto3" json:"previous_justified_slot,omitempty"`
	PreviousJustifiedBlockRoot []byte   `protobuf:"bytes,8,opt,name=previous_justified_block_root,json=previousJustifiedBlockRoot,proto3" json:"previous_justified_block_root,omitempty" ssz-size:"32"`
	XXX_NoUnkeyedLiteral       struct{} `json:"-"`
	XXX_unrecognized           []byte   `json:"-"`
	XXX_sizecache              int32    `json:"-"`
}

func (m *ChainHead) Reset()         { *m = ChainHead{} }
func (m *ChainHead) String() string { return proto.CompactTextString(m) }
func (*ChainHead) ProtoMessage()    {}
func (*ChainHead) Descriptor() ([]byte, []int) {
	return fileDescriptor_678c88b69c3c78d4, []int{4}
}
func (m *ChainHead) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChainHead) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChainHead.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ChainHead) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChainHead.Merge(m, src)
}
func (m *ChainHead) XXX_Size() int {
	return m.Size()
}
func (m *ChainHead) XXX_DiscardUnknown() {
	xxx_messageInfo_ChainHead.DiscardUnknown(m)
}

var xxx_messageInfo_ChainHead proto.InternalMessageInfo

func (m *ChainHead) GetBlockRoot() []byte {
	if m != nil {
		return m.BlockRoot
	}
	return nil
}

func (m *ChainHead) GetBlockSlot() uint64 {
	if m != nil {
		return m.BlockSlot
	}
	return 0
}

func (m *ChainHead) GetFinalizedSlot() uint64 {
	if m != nil {
		return m.FinalizedSlot
	}
	return 0
}

func (m *ChainHead) GetFinalizedBlockRoot() []byte {
	if m != nil {
		return m.FinalizedBlockRoot
	}
	return nil
}

func (m *ChainHead) GetJustifiedSlot() uint64 {
	if m != nil {
		return m.JustifiedSlot
	}
	return 0
}

func (m *ChainHead) GetJustifiedBlockRoot() []byte {
	if m != nil {
		return m.JustifiedBlockRoot
	}
	return nil
}

func (m *ChainHead) GetPreviousJustifiedSlot() uint64 {
	if m != nil {
		return m.PreviousJustifiedSlot
	}
	return 0
}

func (m *ChainHead) GetPreviousJustifiedBlockRoot() []byte {
	if m != nil {
		return m.PreviousJustifiedBlockRoot
	}
	return nil
}

type GetValidatorBalancesRequest struct {
	Epoch                uint64   `protobuf:"varint,1,opt,name=epoch,proto3" json:"epoch,omitempty"`
	PublicKeys           [][]byte `protobuf:"bytes,2,rep,name=public_keys,json=publicKeys,proto3" json:"public_keys,omitempty" ssz-size:"?,48"`
	Indices              []uint64 `protobuf:"varint,3,rep,packed,name=indices,proto3" json:"indices,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetValidatorBalancesRequest) Reset()         { *m = GetValidatorBalancesRequest{} }
func (m *GetValidatorBalancesRequest) String() string { return proto.CompactTextString(m) }
func (*GetValidatorBalancesRequest) ProtoMessage()    {}
func (*GetValidatorBalancesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_678c88b69c3c78d4, []int{5}
}
func (m *GetValidatorBalancesRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetValidatorBalancesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetValidatorBalancesRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetValidatorBalancesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetValidatorBalancesRequest.Merge(m, src)
}
func (m *GetValidatorBalancesRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetValidatorBalancesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetValidatorBalancesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetValidatorBalancesRequest proto.InternalMessageInfo

func (m *GetValidatorBalancesRequest) GetEpoch() uint64 {
	if m != nil {
		return m.Epoch
	}
	return 0
}

func (m *GetValidatorBalancesRequest) GetPublicKeys() [][]byte {
	if m != nil {
		return m.PublicKeys
	}
	return nil
}

func (m *GetValidatorBalancesRequest) GetIndices() []uint64 {
	if m != nil {
		return m.Indices
	}
	return nil
}

type ValidatorBalances struct {
	Balances             []*ValidatorBalances_Balance `protobuf:"bytes,1,rep,name=balances,proto3" json:"balances,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                     `json:"-"`
	XXX_unrecognized     []byte                       `json:"-"`
	XXX_sizecache        int32                        `json:"-"`
}

func (m *ValidatorBalances) Reset()         { *m = ValidatorBalances{} }
func (m *ValidatorBalances) String() string { return proto.CompactTextString(m) }
func (*ValidatorBalances) ProtoMessage()    {}
func (*ValidatorBalances) Descriptor() ([]byte, []int) {
	return fileDescriptor_678c88b69c3c78d4, []int{6}
}
func (m *ValidatorBalances) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ValidatorBalances) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ValidatorBalances.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ValidatorBalances) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ValidatorBalances.Merge(m, src)
}
func (m *ValidatorBalances) XXX_Size() int {
	return m.Size()
}
func (m *ValidatorBalances) XXX_DiscardUnknown() {
	xxx_messageInfo_ValidatorBalances.DiscardUnknown(m)
}

var xxx_messageInfo_ValidatorBalances proto.InternalMessageInfo

func (m *ValidatorBalances) GetBalances() []*ValidatorBalances_Balance {
	if m != nil {
		return m.Balances
	}
	return nil
}

type ValidatorBalances_Balance struct {
	PublicKey            []byte   `protobuf:"bytes,1,opt,name=public_key,json=publicKey,proto3" json:"public_key,omitempty" ssz-size:"48"`
	Index                uint64   `protobuf:"varint,2,opt,name=index,proto3" json:"index,omitempty"`
	Balance              uint64   `protobuf:"varint,3,opt,name=balance,proto3" json:"balance,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ValidatorBalances_Balance) Reset()         { *m = ValidatorBalances_Balance{} }
func (m *ValidatorBalances_Balance) String() string { return proto.CompactTextString(m) }
func (*ValidatorBalances_Balance) ProtoMessage()    {}
func (*ValidatorBalances_Balance) Descriptor() ([]byte, []int) {
	return fileDescriptor_678c88b69c3c78d4, []int{6, 0}
}
func (m *ValidatorBalances_Balance) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ValidatorBalances_Balance) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ValidatorBalances_Balance.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ValidatorBalances_Balance) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ValidatorBalances_Balance.Merge(m, src)
}
func (m *ValidatorBalances_Balance) XXX_Size() int {
	return m.Size()
}
func (m *ValidatorBalances_Balance) XXX_DiscardUnknown() {
	xxx_messageInfo_ValidatorBalances_Balance.DiscardUnknown(m)
}

var xxx_messageInfo_ValidatorBalances_Balance proto.InternalMessageInfo

func (m *ValidatorBalances_Balance) GetPublicKey() []byte {
	if m != nil {
		return m.PublicKey
	}
	return nil
}

func (m *ValidatorBalances_Balance) GetIndex() uint64 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *ValidatorBalances_Balance) GetBalance() uint64 {
	if m != nil {
		return m.Balance
	}
	return 0
}

type GetValidatorsRequest struct {
	// Types that are valid to be assigned to QueryFilter:
	//	*GetValidatorsRequest_Epoch
	//	*GetValidatorsRequest_Genesis
	QueryFilter          isGetValidatorsRequest_QueryFilter `protobuf_oneof:"query_filter"`
	PageSize             int32                              `protobuf:"varint,3,opt,name=page_size,json=pageSize,proto3" json:"page_size,omitempty"`
	PageToken            string                             `protobuf:"bytes,4,opt,name=page_token,json=pageToken,proto3" json:"page_token,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                           `json:"-"`
	XXX_unrecognized     []byte                             `json:"-"`
	XXX_sizecache        int32                              `json:"-"`
}

func (m *GetValidatorsRequest) Reset()         { *m = GetValidatorsRequest{} }
func (m *GetValidatorsRequest) String() string { return proto.CompactTextString(m) }
func (*GetValidatorsRequest) ProtoMessage()    {}
func (*GetValidatorsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_678c88b69c3c78d4, []int{7}
}
func (m *GetValidatorsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetValidatorsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetValidatorsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetValidatorsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetValidatorsRequest.Merge(m, src)
}
func (m *GetValidatorsRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetValidatorsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetValidatorsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetValidatorsRequest proto.InternalMessageInfo

type isGetValidatorsRequest_QueryFilter interface {
	isGetValidatorsRequest_QueryFilter()
	MarshalTo([]byte) (int, error)
	Size() int
}

type GetValidatorsRequest_Epoch struct {
	Epoch uint64 `protobuf:"varint,1,opt,name=epoch,proto3,oneof"`
}
type GetValidatorsRequest_Genesis struct {
	Genesis bool `protobuf:"varint,2,opt,name=genesis,proto3,oneof"`
}

func (*GetValidatorsRequest_Epoch) isGetValidatorsRequest_QueryFilter()   {}
func (*GetValidatorsRequest_Genesis) isGetValidatorsRequest_QueryFilter() {}

func (m *GetValidatorsRequest) GetQueryFilter() isGetValidatorsRequest_QueryFilter {
	if m != nil {
		return m.QueryFilter
	}
	return nil
}

func (m *GetValidatorsRequest) GetEpoch() uint64 {
	if x, ok := m.GetQueryFilter().(*GetValidatorsRequest_Epoch); ok {
		return x.Epoch
	}
	return 0
}

func (m *GetValidatorsRequest) GetGenesis() bool {
	if x, ok := m.GetQueryFilter().(*GetValidatorsRequest_Genesis); ok {
		return x.Genesis
	}
	return false
}

func (m *GetValidatorsRequest) GetPageSize() int32 {
	if m != nil {
		return m.PageSize
	}
	return 0
}

func (m *GetValidatorsRequest) GetPageToken() string {
	if m != nil {
		return m.PageToken
	}
	return ""
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*GetValidatorsRequest) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _GetValidatorsRequest_OneofMarshaler, _GetValidatorsRequest_OneofUnmarshaler, _GetValidatorsRequest_OneofSizer, []interface{}{
		(*GetValidatorsRequest_Epoch)(nil),
		(*GetValidatorsRequest_Genesis)(nil),
	}
}

func _GetValidatorsRequest_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*GetValidatorsRequest)
	// query_filter
	switch x := m.QueryFilter.(type) {
	case *GetValidatorsRequest_Epoch:
		_ = b.EncodeVarint(1<<3 | proto.WireVarint)
		_ = b.EncodeVarint(uint64(x.Epoch))
	case *GetValidatorsRequest_Genesis:
		t := uint64(0)
		if x.Genesis {
			t = 1
		}
		_ = b.EncodeVarint(2<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case nil:
	default:
		return fmt.Errorf("GetValidatorsRequest.QueryFilter has unexpected type %T", x)
	}
	return nil
}

func _GetValidatorsRequest_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*GetValidatorsRequest)
	switch tag {
	case 1: // query_filter.epoch
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.QueryFilter = &GetValidatorsRequest_Epoch{x}
		return true, err
	case 2: // query_filter.genesis
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.QueryFilter = &GetValidatorsRequest_Genesis{x != 0}
		return true, err
	default:
		return false, nil
	}
}

func _GetValidatorsRequest_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*GetValidatorsRequest)
	// query_filter
	switch x := m.QueryFilter.(type) {
	case *GetValidatorsRequest_Epoch:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(x.Epoch))
	case *GetValidatorsRequest_Genesis:
		n += 1 // tag and wire
		n += 1
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type Validators struct {
	Epoch                uint64       `protobuf:"varint,1,opt,name=epoch,proto3" json:"epoch,omitempty"`
	Validators           []*Validator `protobuf:"bytes,2,rep,name=validators,proto3" json:"validators,omitempty"`
	NextPageToken        string       `protobuf:"bytes,3,opt,name=next_page_token,json=nextPageToken,proto3" json:"next_page_token,omitempty"`
	TotalSize            int32        `protobuf:"varint,4,opt,name=total_size,json=totalSize,proto3" json:"total_size,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *Validators) Reset()         { *m = Validators{} }
func (m *Validators) String() string { return proto.CompactTextString(m) }
func (*Validators) ProtoMessage()    {}
func (*Validators) Descriptor() ([]byte, []int) {
	return fileDescriptor_678c88b69c3c78d4, []int{8}
}
func (m *Validators) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Validators) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Validators.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Validators) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Validators.Merge(m, src)
}
func (m *Validators) XXX_Size() int {
	return m.Size()
}
func (m *Validators) XXX_DiscardUnknown() {
	xxx_messageInfo_Validators.DiscardUnknown(m)
}

var xxx_messageInfo_Validators proto.InternalMessageInfo

func (m *Validators) GetEpoch() uint64 {
	if m != nil {
		return m.Epoch
	}
	return 0
}

func (m *Validators) GetValidators() []*Validator {
	if m != nil {
		return m.Validators
	}
	return nil
}

func (m *Validators) GetNextPageToken() string {
	if m != nil {
		return m.NextPageToken
	}
	return ""
}

func (m *Validators) GetTotalSize() int32 {
	if m != nil {
		return m.TotalSize
	}
	return 0
}

type GetValidatorActiveSetChangesRequest struct {
	Epoch                uint64   `protobuf:"varint,1,opt,name=epoch,proto3" json:"epoch,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetValidatorActiveSetChangesRequest) Reset()         { *m = GetValidatorActiveSetChangesRequest{} }
func (m *GetValidatorActiveSetChangesRequest) String() string { return proto.CompactTextString(m) }
func (*GetValidatorActiveSetChangesRequest) ProtoMessage()    {}
func (*GetValidatorActiveSetChangesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_678c88b69c3c78d4, []int{9}
}
func (m *GetValidatorActiveSetChangesRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetValidatorActiveSetChangesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetValidatorActiveSetChangesRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetValidatorActiveSetChangesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetValidatorActiveSetChangesRequest.Merge(m, src)
}
func (m *GetValidatorActiveSetChangesRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetValidatorActiveSetChangesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetValidatorActiveSetChangesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetValidatorActiveSetChangesRequest proto.InternalMessageInfo

func (m *GetValidatorActiveSetChangesRequest) GetEpoch() uint64 {
	if m != nil {
		return m.Epoch
	}
	return 0
}

type ActiveSetChanges struct {
	Epoch                uint64   `protobuf:"varint,1,opt,name=epoch,proto3" json:"epoch,omitempty"`
	ActivatedPublicKeys  [][]byte `protobuf:"bytes,2,rep,name=activated_public_keys,json=activatedPublicKeys,proto3" json:"activated_public_keys,omitempty" ssz-size:"?,48"`
	ExitedPublicKeys     [][]byte `protobuf:"bytes,3,rep,name=exited_public_keys,json=exitedPublicKeys,proto3" json:"exited_public_keys,omitempty" ssz-size:"?,48"`
	EjectedPublicKeys    [][]byte `protobuf:"bytes,4,rep,name=ejected_public_keys,json=ejectedPublicKeys,proto3" json:"ejected_public_keys,omitempty" ssz-size:"?,48"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ActiveSetChanges) Reset()         { *m = ActiveSetChanges{} }
func (m *ActiveSetChanges) String() string { return proto.CompactTextString(m) }
func (*ActiveSetChanges) ProtoMessage()    {}
func (*ActiveSetChanges) Descriptor() ([]byte, []int) {
	return fileDescriptor_678c88b69c3c78d4, []int{10}
}
func (m *ActiveSetChanges) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ActiveSetChanges) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ActiveSetChanges.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ActiveSetChanges) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActiveSetChanges.Merge(m, src)
}
func (m *ActiveSetChanges) XXX_Size() int {
	return m.Size()
}
func (m *ActiveSetChanges) XXX_DiscardUnknown() {
	xxx_messageInfo_ActiveSetChanges.DiscardUnknown(m)
}

var xxx_messageInfo_ActiveSetChanges proto.InternalMessageInfo

func (m *ActiveSetChanges) GetEpoch() uint64 {
	if m != nil {
		return m.Epoch
	}
	return 0
}

func (m *ActiveSetChanges) GetActivatedPublicKeys() [][]byte {
	if m != nil {
		return m.ActivatedPublicKeys
	}
	return nil
}

func (m *ActiveSetChanges) GetExitedPublicKeys() [][]byte {
	if m != nil {
		return m.ExitedPublicKeys
	}
	return nil
}

func (m *ActiveSetChanges) GetEjectedPublicKeys() [][]byte {
	if m != nil {
		return m.EjectedPublicKeys
	}
	return nil
}

type ValidatorQueue struct {
	ChurnLimit           uint64   `protobuf:"varint,1,opt,name=churn_limit,json=churnLimit,proto3" json:"churn_limit,omitempty"`
	ActivationPublicKeys [][]byte `protobuf:"bytes,2,rep,name=activation_public_keys,json=activationPublicKeys,proto3" json:"activation_public_keys,omitempty" ssz-size:"?,48"`
	ExitPublicKeys       [][]byte `protobuf:"bytes,3,rep,name=exit_public_keys,json=exitPublicKeys,proto3" json:"exit_public_keys,omitempty" ssz-size:"?,48"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ValidatorQueue) Reset()         { *m = ValidatorQueue{} }
func (m *ValidatorQueue) String() string { return proto.CompactTextString(m) }
func (*ValidatorQueue) ProtoMessage()    {}
func (*ValidatorQueue) Descriptor() ([]byte, []int) {
	return fileDescriptor_678c88b69c3c78d4, []int{11}
}
func (m *ValidatorQueue) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ValidatorQueue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ValidatorQueue.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ValidatorQueue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ValidatorQueue.Merge(m, src)
}
func (m *ValidatorQueue) XXX_Size() int {
	return m.Size()
}
func (m *ValidatorQueue) XXX_DiscardUnknown() {
	xxx_messageInfo_ValidatorQueue.DiscardUnknown(m)
}

var xxx_messageInfo_ValidatorQueue proto.InternalMessageInfo

func (m *ValidatorQueue) GetChurnLimit() uint64 {
	if m != nil {
		return m.ChurnLimit
	}
	return 0
}

func (m *ValidatorQueue) GetActivationPublicKeys() [][]byte {
	if m != nil {
		return m.ActivationPublicKeys
	}
	return nil
}

func (m *ValidatorQueue) GetExitPublicKeys() [][]byte {
	if m != nil {
		return m.ExitPublicKeys
	}
	return nil
}

type ListValidatorAssignmentsRequest struct {
	Epoch                uint64   `protobuf:"varint,1,opt,name=epoch,proto3" json:"epoch,omitempty"`
	PublicKeys           [][]byte `protobuf:"bytes,2,rep,name=public_keys,json=publicKeys,proto3" json:"public_keys,omitempty" ssz-size:"?,48"`
	Indices              []uint64 `protobuf:"varint,3,rep,packed,name=indices,proto3" json:"indices,omitempty"`
	PageSize             int32    `protobuf:"varint,4,opt,name=page_size,json=pageSize,proto3" json:"page_size,omitempty"`
	PageToken            string   `protobuf:"bytes,5,opt,name=page_token,json=pageToken,proto3" json:"page_token,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListValidatorAssignmentsRequest) Reset()         { *m = ListValidatorAssignmentsRequest{} }
func (m *ListValidatorAssignmentsRequest) String() string { return proto.CompactTextString(m) }
func (*ListValidatorAssignmentsRequest) ProtoMessage()    {}
func (*ListValidatorAssignmentsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_678c88b69c3c78d4, []int{12}
}
func (m *ListValidatorAssignmentsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListValidatorAssignmentsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListValidatorAssignmentsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListValidatorAssignmentsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListValidatorAssignmentsRequest.Merge(m, src)
}
func (m *ListValidatorAssignmentsRequest) XXX_Size() int {
	return m.Size()
}
func (m *ListValidatorAssignmentsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListValidatorAssignmentsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListValidatorAssignmentsRequest proto.InternalMessageInfo

func (m *ListValidatorAssignmentsRequest) GetEpoch() uint64 {
	if m != nil {
		return m.Epoch
	}
	return 0
}

func (m *ListValidatorAssignmentsRequest) GetPublicKeys() [][]byte {
	if m != nil {
		return m.PublicKeys
	}
	return nil
}

func (m *ListValidatorAssignmentsRequest) GetIndices() []uint64 {
	if m != nil {
		return m.Indices
	}
	return nil
}

func (m *ListValidatorAssignmentsRequest) GetPageSize() int32 {
	if m != nil {
		return m.PageSize
	}
	return 0
}

func (m *ListValidatorAssignmentsRequest) GetPageToken() string {
	if m != nil {
		return m.PageToken
	}
	return ""
}

type ValidatorAssignments struct {
	Epoch                uint64                                      `protobuf:"varint,1,opt,name=epoch,proto3" json:"epoch,omitempty"`
	Assignments          []*ValidatorAssignments_CommitteeAssignment `protobuf:"bytes,2,rep,name=assignments,proto3" json:"assignments,omitempty"`
	NextPageToken        string                                      `protobuf:"bytes,3,opt,name=next_page_token,json=nextPageToken,proto3" json:"next_page_token,omitempty"`
	TotalSize            int32                                       `protobuf:"varint,4,opt,name=total_size,json=totalSize,proto3" json:"total_size,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                    `json:"-"`
	XXX_unrecognized     []byte                                      `json:"-"`
	XXX_sizecache        int32                                       `json:"-"`
}

func (m *ValidatorAssignments) Reset()         { *m = ValidatorAssignments{} }
func (m *ValidatorAssignments) String() string { return proto.CompactTextString(m) }
func (*ValidatorAssignments) ProtoMessage()    {}
func (*ValidatorAssignments) Descriptor() ([]byte, []int) {
	return fileDescriptor_678c88b69c3c78d4, []int{13}
}
func (m *ValidatorAssignments) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ValidatorAssignments) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ValidatorAssignments.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ValidatorAssignments) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ValidatorAssignments.Merge(m, src)
}
func (m *ValidatorAssignments) XXX_Size() int {
	return m.Size()
}
func (m *ValidatorAssignments) XXX_DiscardUnknown() {
	xxx_messageInfo_ValidatorAssignments.DiscardUnknown(m)
}

var xxx_messageInfo_ValidatorAssignments proto.InternalMessageInfo

func (m *ValidatorAssignments) GetEpoch() uint64 {
	if m != nil {
		return m.Epoch
	}
	return 0
}

func (m *ValidatorAssignments) GetAssignments() []*ValidatorAssignments_CommitteeAssignment {
	if m != nil {
		return m.Assignments
	}
	return nil
}

func (m *ValidatorAssignments) GetNextPageToken() string {
	if m != nil {
		return m.NextPageToken
	}
	return ""
}

func (m *ValidatorAssignments) GetTotalSize() int32 {
	if m != nil {
		return m.TotalSize
	}
	return 0
}

type ValidatorAssignments_CommitteeAssignment struct {
	CrosslinkCommittees  []uint64 `protobuf:"varint,1,rep,packed,name=crosslink_committees,json=crosslinkCommittees,proto3" json:"crosslink_committees,omitempty"`
	Shard                uint64   `protobuf:"varint,2,opt,name=shard,proto3" json:"shard,omitempty"`
	Slot                 uint64   `protobuf:"varint,3,opt,name=slot,proto3" json:"slot,omitempty"`
	Proposer             bool     `protobuf:"varint,4,opt,name=proposer,proto3" json:"proposer,omitempty"`
	PublicKey            []byte   `protobuf:"bytes,5,opt,name=public_key,json=publicKey,proto3" json:"public_key,omitempty" ssz-size:"48"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ValidatorAssignments_CommitteeAssignment) Reset() {
	*m = ValidatorAssignments_CommitteeAssignment{}
}
func (m *ValidatorAssignments_CommitteeAssignment) String() string { return proto.CompactTextString(m) }
func (*ValidatorAssignments_CommitteeAssignment) ProtoMessage()    {}
func (*ValidatorAssignments_CommitteeAssignment) Descriptor() ([]byte, []int) {
	return fileDescriptor_678c88b69c3c78d4, []int{13, 0}
}
func (m *ValidatorAssignments_CommitteeAssignment) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ValidatorAssignments_CommitteeAssignment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ValidatorAssignments_CommitteeAssignment.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ValidatorAssignments_CommitteeAssignment) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ValidatorAssignments_CommitteeAssignment.Merge(m, src)
}
func (m *ValidatorAssignments_CommitteeAssignment) XXX_Size() int {
	return m.Size()
}
func (m *ValidatorAssignments_CommitteeAssignment) XXX_DiscardUnknown() {
	xxx_messageInfo_ValidatorAssignments_CommitteeAssignment.DiscardUnknown(m)
}

var xxx_messageInfo_ValidatorAssignments_CommitteeAssignment proto.InternalMessageInfo

func (m *ValidatorAssignments_CommitteeAssignment) GetCrosslinkCommittees() []uint64 {
	if m != nil {
		return m.CrosslinkCommittees
	}
	return nil
}

func (m *ValidatorAssignments_CommitteeAssignment) GetShard() uint64 {
	if m != nil {
		return m.Shard
	}
	return 0
}

func (m *ValidatorAssignments_CommitteeAssignment) GetSlot() uint64 {
	if m != nil {
		return m.Slot
	}
	return 0
}

func (m *ValidatorAssignments_CommitteeAssignment) GetProposer() bool {
	if m != nil {
		return m.Proposer
	}
	return false
}

func (m *ValidatorAssignments_CommitteeAssignment) GetPublicKey() []byte {
	if m != nil {
		return m.PublicKey
	}
	return nil
}

type GetValidatorParticipationRequest struct {
	Epoch                uint64   `protobuf:"varint,1,opt,name=epoch,proto3" json:"epoch,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetValidatorParticipationRequest) Reset()         { *m = GetValidatorParticipationRequest{} }
func (m *GetValidatorParticipationRequest) String() string { return proto.CompactTextString(m) }
func (*GetValidatorParticipationRequest) ProtoMessage()    {}
func (*GetValidatorParticipationRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_678c88b69c3c78d4, []int{14}
}
func (m *GetValidatorParticipationRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetValidatorParticipationRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetValidatorParticipationRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetValidatorParticipationRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetValidatorParticipationRequest.Merge(m, src)
}
func (m *GetValidatorParticipationRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetValidatorParticipationRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetValidatorParticipationRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetValidatorParticipationRequest proto.InternalMessageInfo

func (m *GetValidatorParticipationRequest) GetEpoch() uint64 {
	if m != nil {
		return m.Epoch
	}
	return 0
}

type ValidatorParticipation struct {
	Epoch                   uint64   `protobuf:"varint,1,opt,name=epoch,proto3" json:"epoch,omitempty"`
	Finalized               bool     `protobuf:"varint,2,opt,name=finalized,proto3" json:"finalized,omitempty"`
	GlobalParticipationRate float32  `protobuf:"fixed32,3,opt,name=global_participation_rate,json=globalParticipationRate,proto3" json:"global_participation_rate,omitempty"`
	VotedEther              uint64   `protobuf:"varint,4,opt,name=voted_ether,json=votedEther,proto3" json:"voted_ether,omitempty"`
	EligibleEther           uint64   `protobuf:"varint,5,opt,name=eligible_ether,json=eligibleEther,proto3" json:"eligible_ether,omitempty"`
	XXX_NoUnkeyedLiteral    struct{} `json:"-"`
	XXX_unrecognized        []byte   `json:"-"`
	XXX_sizecache           int32    `json:"-"`
}

func (m *ValidatorParticipation) Reset()         { *m = ValidatorParticipation{} }
func (m *ValidatorParticipation) String() string { return proto.CompactTextString(m) }
func (*ValidatorParticipation) ProtoMessage()    {}
func (*ValidatorParticipation) Descriptor() ([]byte, []int) {
	return fileDescriptor_678c88b69c3c78d4, []int{15}
}
func (m *ValidatorParticipation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ValidatorParticipation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ValidatorParticipation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ValidatorParticipation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ValidatorParticipation.Merge(m, src)
}
func (m *ValidatorParticipation) XXX_Size() int {
	return m.Size()
}
func (m *ValidatorParticipation) XXX_DiscardUnknown() {
	xxx_messageInfo_ValidatorParticipation.DiscardUnknown(m)
}

var xxx_messageInfo_ValidatorParticipation proto.InternalMessageInfo

func (m *ValidatorParticipation) GetEpoch() uint64 {
	if m != nil {
		return m.Epoch
	}
	return 0
}

func (m *ValidatorParticipation) GetFinalized() bool {
	if m != nil {
		return m.Finalized
	}
	return false
}

func (m *ValidatorParticipation) GetGlobalParticipationRate() float32 {
	if m != nil {
		return m.GlobalParticipationRate
	}
	return 0
}

func (m *ValidatorParticipation) GetVotedEther() uint64 {
	if m != nil {
		return m.VotedEther
	}
	return 0
}

func (m *ValidatorParticipation) GetEligibleEther() uint64 {
	if m != nil {
		return m.EligibleEther
	}
	return 0
}

type AttestationPoolResponse struct {
	Attestations         []*Attestation `protobuf:"bytes,1,rep,name=attestations,proto3" json:"attestations,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *AttestationPoolResponse) Reset()         { *m = AttestationPoolResponse{} }
func (m *AttestationPoolResponse) String() string { return proto.CompactTextString(m) }
func (*AttestationPoolResponse) ProtoMessage()    {}
func (*AttestationPoolResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_678c88b69c3c78d4, []int{16}
}
func (m *AttestationPoolResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AttestationPoolResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AttestationPoolResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AttestationPoolResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AttestationPoolResponse.Merge(m, src)
}
func (m *AttestationPoolResponse) XXX_Size() int {
	return m.Size()
}
func (m *AttestationPoolResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AttestationPoolResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AttestationPoolResponse proto.InternalMessageInfo

func (m *AttestationPoolResponse) GetAttestations() []*Attestation {
	if m != nil {
		return m.Attestations
	}
	return nil
}

func init() {
	proto.RegisterType((*ListAttestationsRequest)(nil), "ethereum.eth.v1alpha1.ListAttestationsRequest")
	proto.RegisterType((*ListAttestationsResponse)(nil), "ethereum.eth.v1alpha1.ListAttestationsResponse")
	proto.RegisterType((*ListBlocksRequest)(nil), "ethereum.eth.v1alpha1.ListBlocksRequest")
	proto.RegisterType((*ListBlocksResponse)(nil), "ethereum.eth.v1alpha1.ListBlocksResponse")
	proto.RegisterType((*ChainHead)(nil), "ethereum.eth.v1alpha1.ChainHead")
	proto.RegisterType((*GetValidatorBalancesRequest)(nil), "ethereum.eth.v1alpha1.GetValidatorBalancesRequest")
	proto.RegisterType((*ValidatorBalances)(nil), "ethereum.eth.v1alpha1.ValidatorBalances")
	proto.RegisterType((*ValidatorBalances_Balance)(nil), "ethereum.eth.v1alpha1.ValidatorBalances.Balance")
	proto.RegisterType((*GetValidatorsRequest)(nil), "ethereum.eth.v1alpha1.GetValidatorsRequest")
	proto.RegisterType((*Validators)(nil), "ethereum.eth.v1alpha1.Validators")
	proto.RegisterType((*GetValidatorActiveSetChangesRequest)(nil), "ethereum.eth.v1alpha1.GetValidatorActiveSetChangesRequest")
	proto.RegisterType((*ActiveSetChanges)(nil), "ethereum.eth.v1alpha1.ActiveSetChanges")
	proto.RegisterType((*ValidatorQueue)(nil), "ethereum.eth.v1alpha1.ValidatorQueue")
	proto.RegisterType((*ListValidatorAssignmentsRequest)(nil), "ethereum.eth.v1alpha1.ListValidatorAssignmentsRequest")
	proto.RegisterType((*ValidatorAssignments)(nil), "ethereum.eth.v1alpha1.ValidatorAssignments")
	proto.RegisterType((*ValidatorAssignments_CommitteeAssignment)(nil), "ethereum.eth.v1alpha1.ValidatorAssignments.CommitteeAssignment")
	proto.RegisterType((*GetValidatorParticipationRequest)(nil), "ethereum.eth.v1alpha1.GetValidatorParticipationRequest")
	proto.RegisterType((*ValidatorParticipation)(nil), "ethereum.eth.v1alpha1.ValidatorParticipation")
	proto.RegisterType((*AttestationPoolResponse)(nil), "ethereum.eth.v1alpha1.AttestationPoolResponse")
}

func init() {
	proto.RegisterFile("proto/eth/v1alpha1/beacon_chain.proto", fileDescriptor_678c88b69c3c78d4)
}

var fileDescriptor_678c88b69c3c78d4 = []byte{
	// 1628 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x58, 0xcd, 0x6f, 0x1c, 0xc5,
	0x12, 0xcf, 0x78, 0xd7, 0x5f, 0xb5, 0xfe, 0x88, 0xdb, 0x5f, 0x9b, 0x71, 0x6c, 0x6f, 0xc6, 0xb1,
	0xdf, 0x46, 0x49, 0x76, 0x63, 0x27, 0x2f, 0x2f, 0x72, 0xf4, 0x94, 0x17, 0x5b, 0x79, 0x31, 0x10,
	0x21, 0x33, 0x89, 0x38, 0x70, 0x59, 0xf5, 0xce, 0xb6, 0x77, 0x3b, 0x9e, 0x9d, 0x9e, 0xcc, 0xf4,
	0x5a, 0xb1, 0x6f, 0x80, 0x84, 0xc4, 0x19, 0x09, 0xc4, 0x05, 0xb8, 0x22, 0xc4, 0x09, 0x89, 0x0b,
	0x17, 0x04, 0x17, 0x4e, 0x28, 0x12, 0x12, 0xc7, 0x08, 0x45, 0xfc, 0x05, 0xb9, 0x20, 0x6e, 0x68,
	0xba, 0x7b, 0x3e, 0x76, 0xbd, 0xb3, 0xbb, 0x48, 0x11, 0xb7, 0xe9, 0xea, 0xea, 0x5f, 0xfd, 0xba,
	0xaa, 0xba, 0xba, 0x7a, 0x60, 0xdd, 0xf5, 0x18, 0x67, 0x65, 0xc2, 0x1b, 0xe5, 0xa3, 0x4d, 0x6c,
	0xbb, 0x0d, 0xbc, 0x59, 0xae, 0x12, 0x6c, 0x31, 0xa7, 0x62, 0x35, 0x30, 0x75, 0x4a, 0x62, 0x1e,
	0xcd, 0x13, 0xde, 0x20, 0x1e, 0x69, 0x35, 0x4b, 0x84, 0x37, 0x4a, 0xa1, 0xa6, 0x7e, 0xb5, 0x4e,
	0x79, 0xa3, 0x55, 0x2d, 0x59, 0xac, 0x59, 0xae, 0xb3, 0x3a, 0x2b, 0x0b, 0xed, 0x6a, 0xeb, 0x40,
	0x8c, 0x24, 0x74, 0xf0, 0x25, 0x51, 0xf4, 0xf3, 0x75, 0xc6, 0xea, 0x36, 0x29, 0x63, 0x97, 0x96,
	0xb1, 0xe3, 0x30, 0x8e, 0x39, 0x65, 0x8e, 0xaf, 0x66, 0x97, 0xd4, 0x6c, 0x84, 0x41, 0x9a, 0x2e,
	0x3f, 0x56, 0x93, 0x17, 0xbb, 0xf0, 0xc4, 0x9c, 0x13, 0x5f, 0x62, 0x28, 0xad, 0x1e, 0xbb, 0xa9,
	0xda, 0xcc, 0x3a, 0x54, 0x6a, 0x46, 0x17, 0xb5, 0x23, 0x6c, 0xd3, 0x1a, 0xe6, 0xcc, 0x93, 0x3a,
	0xc6, 0xe7, 0x43, 0xb0, 0xf8, 0x80, 0xfa, 0xfc, 0x6e, 0x6c, 0xc4, 0x37, 0xc9, 0x93, 0x16, 0xf1,
	0x39, 0x2a, 0xc2, 0x74, 0x83, 0xe0, 0x9a, 0xc4, 0xac, 0x78, 0x8c, 0xf1, 0xbc, 0x56, 0xd0, 0x8a,
	0x13, 0x7b, 0x67, 0xcc, 0xc9, 0x60, 0x62, 0x27, 0x90, 0x9b, 0x8c, 0x71, 0xb4, 0x06, 0x13, 0x3e,
	0x6b, 0x79, 0x16, 0xa9, 0x10, 0x97, 0x59, 0x8d, 0xfc, 0x50, 0x41, 0x2b, 0x66, 0xf7, 0xce, 0x98,
	0x39, 0x29, 0xbd, 0x17, 0x08, 0xd1, 0x05, 0x50, 0x43, 0x09, 0x95, 0x51, 0x50, 0x20, 0x85, 0x21,
	0x0e, 0xc7, 0x5e, 0x9d, 0x70, 0x85, 0x93, 0x0d, 0x71, 0xa4, 0x34, 0xc2, 0x51, 0x4a, 0x02, 0x67,
	0x38, 0xc4, 0x91, 0x42, 0x81, 0xb3, 0x04, 0xe3, 0x2e, 0xae, 0x93, 0x8a, 0x4f, 0x4f, 0x48, 0x7e,
	0xa4, 0xa0, 0x15, 0x87, 0xcd, 0xb1, 0x40, 0xf0, 0x90, 0x9e, 0x10, 0xb4, 0x0c, 0x20, 0x26, 0x39,
	0x3b, 0x24, 0x4e, 0x7e, 0xb4, 0xa0, 0x15, 0xc7, 0x4d, 0xa1, 0xfe, 0x28, 0x10, 0xec, 0x4c, 0xc1,
	0xc4, 0x93, 0x16, 0xf1, 0x8e, 0x2b, 0x07, 0xd4, 0xe6, 0xc4, 0x33, 0xbe, 0xd4, 0x20, 0x7f, 0xda,
	0x43, 0xbe, 0xcb, 0x1c, 0x9f, 0xa0, 0xff, 0xc3, 0x44, 0x22, 0x3c, 0x7e, 0x5e, 0x2b, 0x64, 0x8a,
	0xb9, 0x2d, 0xa3, 0xd4, 0x35, 0x8f, 0x4a, 0x09, 0x08, 0xb3, 0x6d, 0x1d, 0xda, 0x80, 0x69, 0x87,
	0x3c, 0xe5, 0x95, 0x04, 0xb1, 0x21, 0x41, 0x6c, 0x32, 0x10, 0xef, 0x87, 0xe4, 0x02, 0xee, 0x9c,
	0x71, 0x6c, 0xcb, 0x9d, 0x65, 0xc4, 0xce, 0xc6, 0x85, 0x24, 0xd8, 0x9a, 0xf1, 0xab, 0x06, 0x33,
	0x01, 0x57, 0x11, 0x99, 0x28, 0x8e, 0x73, 0x90, 0x6d, 0x0b, 0x9e, 0x18, 0x05, 0x52, 0xdf, 0x66,
	0x3c, 0x8a, 0x95, 0x18, 0xa1, 0x05, 0x18, 0x96, 0xae, 0xcf, 0x28, 0xb1, 0x1c, 0xa2, 0x4d, 0x98,
	0xa3, 0x8e, 0x65, 0xb7, 0x6a, 0xa4, 0xe2, 0x30, 0xc7, 0xc2, 0x0e, 0x73, 0xa8, 0x85, 0x6d, 0x11,
	0xa1, 0x31, 0x73, 0x56, 0xcd, 0xbd, 0x99, 0x98, 0x6a, 0x0f, 0xc2, 0x70, 0xcf, 0x20, 0x8c, 0xf4,
	0x0b, 0xc2, 0x27, 0x1a, 0xa0, 0xe4, 0xc6, 0x94, 0xfb, 0xb7, 0x61, 0x44, 0x24, 0x67, 0x3f, 0xc7,
	0xef, 0x88, 0xc3, 0x21, 0xf3, 0x55, 0xad, 0x78, 0x55, 0x2e, 0xff, 0x21, 0x03, 0xe3, 0xbb, 0x41,
	0x09, 0xd9, 0x23, 0xb8, 0x86, 0xae, 0x01, 0x74, 0x9e, 0x96, 0x9d, 0x99, 0x97, 0xcf, 0x57, 0x27,
	0x7d, 0xff, 0xe4, 0x6a, 0x00, 0xb0, 0x6d, 0x5c, 0xdf, 0x32, 0xcc, 0xf1, 0x6a, 0x74, 0x74, 0x96,
	0xc3, 0x15, 0x71, 0x30, 0xd4, 0xf4, 0xc3, 0x20, 0x1e, 0xeb, 0x30, 0x75, 0x40, 0x1d, 0x6c, 0xd3,
	0x13, 0x52, 0x93, 0x2a, 0x22, 0x30, 0xe6, 0x64, 0x24, 0x15, 0x6a, 0xbb, 0x30, 0x17, 0xab, 0x25,
	0x18, 0x64, 0xd3, 0x18, 0xa0, 0x48, 0x3d, 0x3e, 0xc5, 0xeb, 0x30, 0xf5, 0xb8, 0xe5, 0x73, 0x7a,
	0x40, 0x43, 0x5b, 0xc3, 0xd2, 0x56, 0x24, 0x0d, 0x6d, 0xc5, 0x6a, 0x09, 0x5b, 0x23, 0xa9, 0xb6,
	0x22, 0xf5, 0xd8, 0xd6, 0x4d, 0x58, 0x74, 0x3d, 0x72, 0x44, 0x59, 0xcb, 0xaf, 0x74, 0x18, 0x1d,
	0x15, 0x46, 0xe7, 0xc3, 0xe9, 0xd7, 0xdb, 0x8c, 0x3f, 0x82, 0xe5, 0x2e, 0xeb, 0x12, 0x2c, 0xc6,
	0xd2, 0x58, 0xe8, 0xa7, 0x00, 0x23, 0x36, 0xc6, 0xfb, 0x1a, 0x2c, 0xdd, 0x27, 0xfc, 0xed, 0xb0,
	0x38, 0xee, 0x60, 0x1b, 0x3b, 0x16, 0x49, 0x9c, 0x20, 0x75, 0x2a, 0x34, 0xc1, 0x4d, 0x9d, 0x89,
	0x1b, 0x90, 0x73, 0x5b, 0x55, 0x9b, 0x5a, 0x95, 0x43, 0x72, 0xec, 0xe7, 0x87, 0x0a, 0x99, 0xe2,
	0xc4, 0xce, 0xec, 0xcb, 0xe7, 0xab, 0xd3, 0xb1, 0xe5, 0x3b, 0x57, 0x6e, 0xdc, 0x32, 0x4c, 0x90,
	0x7a, 0x6f, 0x90, 0x63, 0x1f, 0xe5, 0x61, 0x94, 0x3a, 0x35, 0x6a, 0x11, 0x3f, 0x9f, 0x29, 0x64,
	0x8a, 0x59, 0x33, 0x1c, 0x1a, 0x3f, 0x6b, 0x30, 0x73, 0x8a, 0x02, 0x7a, 0x00, 0x63, 0x55, 0xf5,
	0xad, 0xb2, 0xfc, 0x5a, 0x4a, 0x96, 0x9f, 0x5a, 0x5b, 0x52, 0x1f, 0x66, 0x84, 0xa0, 0x1f, 0xc2,
	0xa8, 0x12, 0x06, 0xb9, 0x1a, 0xd3, 0xef, 0x9e, 0xab, 0x01, 0xf7, 0xf1, 0x88, 0x7b, 0xe0, 0x06,
	0xea, 0xd4, 0xc8, 0x53, 0x95, 0xa6, 0x72, 0x10, 0x6c, 0x48, 0xc1, 0xab, 0xdc, 0x0c, 0x87, 0xc6,
	0xc7, 0x1a, 0xcc, 0x25, 0xdd, 0x1a, 0xf9, 0x73, 0xa1, 0xcd, 0x9f, 0x71, 0x95, 0xd1, 0x61, 0xb4,
	0x4e, 0x1c, 0xe2, 0x53, 0x5f, 0x98, 0x18, 0xdb, 0x3b, 0x63, 0x86, 0x82, 0xf6, 0x72, 0x92, 0xe9,
	0x59, 0x4e, 0xb2, 0xfd, 0xca, 0xc9, 0x57, 0x1a, 0x40, 0xcc, 0x2a, 0x25, 0xbc, 0xff, 0x03, 0x88,
	0x6e, 0x4b, 0x19, 0xdd, 0xdc, 0x56, 0xa1, 0x9f, 0xeb, 0xcd, 0xc4, 0x9a, 0x6e, 0x25, 0x26, 0xd3,
	0xbf, 0xc4, 0x64, 0x3b, 0x4b, 0xcc, 0x6d, 0x58, 0x4b, 0x7a, 0xf1, 0xae, 0xc5, 0xe9, 0x11, 0x79,
	0x48, 0xf8, 0x6e, 0x03, 0x3b, 0xf5, 0x3e, 0x49, 0x6a, 0xfc, 0xa9, 0xc1, 0xd9, 0xce, 0x15, 0x29,
	0x1b, 0xbe, 0x0f, 0xf3, 0x38, 0xd0, 0xc4, 0x9c, 0xd4, 0x2a, 0x03, 0x66, 0xf6, 0x6c, 0xb4, 0x62,
	0x3f, 0x4e, 0xf1, 0xbb, 0x80, 0xc8, 0x53, 0xda, 0x89, 0x92, 0x49, 0x47, 0x39, 0x2b, 0xd5, 0x13,
	0x10, 0xbb, 0x30, 0x4b, 0x1e, 0x13, 0xab, 0x13, 0x23, 0x9b, 0x8e, 0x31, 0xa3, 0xf4, 0x63, 0x10,
	0xe3, 0x3b, 0x0d, 0xa6, 0x22, 0xb7, 0xbd, 0xd5, 0x22, 0x2d, 0x82, 0x56, 0x21, 0x67, 0x35, 0x5a,
	0x9e, 0x53, 0xb1, 0x69, 0x93, 0x72, 0xb5, 0x7f, 0x10, 0xa2, 0x07, 0x81, 0x04, 0xbd, 0x06, 0x0b,
	0x6a, 0x4b, 0x94, 0x39, 0x83, 0x7a, 0x61, 0x2e, 0x5e, 0x92, 0xd8, 0xc3, 0x7f, 0x41, 0xec, 0x6b,
	0x50, 0x27, 0x4c, 0x05, 0xca, 0x09, 0xf6, 0x3f, 0x6a, 0xb0, 0x1a, 0xdc, 0x79, 0x71, 0xe0, 0x7d,
	0x9f, 0xd6, 0x9d, 0x26, 0x71, 0xf8, 0x3f, 0x5b, 0x98, 0xda, 0x8f, 0x5e, 0xb6, 0xe7, 0xd1, 0x1b,
	0xee, 0x38, 0x7a, 0xc6, 0xa7, 0x19, 0x98, 0xeb, 0xb6, 0x83, 0x14, 0xea, 0x18, 0x72, 0x38, 0x56,
	0x52, 0xa7, 0xee, 0x4e, 0xbf, 0x53, 0x97, 0xc0, 0x2d, 0xed, 0xb2, 0x66, 0x93, 0x72, 0x4e, 0x48,
	0x2c, 0x34, 0x93, 0x98, 0xaf, 0xe8, 0x54, 0xea, 0xdf, 0x6b, 0x30, 0xdb, 0xc5, 0x56, 0xd0, 0x29,
	0x59, 0x1e, 0xf3, 0x7d, 0x9b, 0x3a, 0x87, 0x15, 0x2b, 0x54, 0x90, 0xb5, 0x3b, 0x6b, 0xce, 0x46,
	0x73, 0xd1, 0x5a, 0xe1, 0x0a, 0xbf, 0x81, 0xbd, 0x5a, 0x58, 0x57, 0xc5, 0x00, 0x21, 0xd5, 0xa0,
	0xc9, 0xa2, 0x2a, 0xdb, 0x33, 0x1d, 0xc6, 0x5c, 0x8f, 0xb9, 0xcc, 0x27, 0x9e, 0x6a, 0xbd, 0xa2,
	0x71, 0x47, 0x3d, 0x1f, 0xee, 0x5f, 0xcf, 0x8d, 0x5b, 0x50, 0x48, 0x16, 0x96, 0x7d, 0xec, 0x71,
	0x6a, 0x51, 0x57, 0x36, 0xa8, 0x3d, 0xab, 0xca, 0x33, 0x0d, 0x16, 0xba, 0xaf, 0x4b, 0x89, 0xeb,
	0x79, 0x18, 0x8f, 0x3a, 0x0e, 0x59, 0xdb, 0xcd, 0x58, 0x80, 0xb6, 0xe1, 0x5c, 0xdd, 0x66, 0x55,
	0x6c, 0x57, 0xdc, 0x24, 0x56, 0xc5, 0xc3, 0x5c, 0xd6, 0xfa, 0x21, 0x73, 0x51, 0x2a, 0xb4, 0x73,
	0xc4, 0x5c, 0x9c, 0xe8, 0x23, 0x16, 0xd4, 0x09, 0x91, 0x23, 0xf2, 0xc9, 0x60, 0x82, 0x10, 0xdd,
	0x0b, 0x24, 0x41, 0x5b, 0x43, 0x6c, 0x5a, 0xa7, 0x55, 0x9b, 0x28, 0x1d, 0xd5, 0xd6, 0x84, 0x52,
	0xa1, 0x66, 0x60, 0x58, 0x4c, 0xf4, 0xe7, 0xfb, 0x8c, 0xd9, 0xaf, 0xba, 0xcb, 0xdf, 0xfa, 0x23,
	0x07, 0x39, 0xd9, 0x8a, 0x8a, 0x8e, 0x11, 0x7d, 0xa6, 0xc1, 0xd9, 0xce, 0xa7, 0x05, 0x2a, 0xa5,
	0xc0, 0xa6, 0xbc, 0xd2, 0xf4, 0xf2, 0xc0, 0xfa, 0x72, 0x37, 0xc6, 0xa5, 0xf7, 0x7e, 0xf9, 0xfd,
	0xa3, 0xa1, 0x35, 0x74, 0xa1, 0xdb, 0x03, 0xb2, 0xdc, 0xf6, 0x2c, 0xf9, 0x50, 0x83, 0xe9, 0x0e,
	0xa7, 0xa0, 0x85, 0x92, 0x7c, 0xc0, 0x96, 0xc2, 0x07, 0x6c, 0xe9, 0x5e, 0xf0, 0x80, 0xd5, 0x4b,
	0xfd, 0xdd, 0x91, 0x74, 0xaa, 0x51, 0x12, 0x34, 0x8a, 0x68, 0xa3, 0x2f, 0x8d, 0xb2, 0x1b, 0xd8,
	0xfd, 0x40, 0x03, 0x88, 0x9f, 0x00, 0xa8, 0xd8, 0x63, 0xdb, 0x6d, 0xcf, 0x1f, 0xfd, 0xd2, 0x00,
	0x9a, 0x8a, 0xd3, 0x9a, 0xe0, 0xb4, 0x8c, 0x96, 0xba, 0x72, 0x52, 0x0f, 0x07, 0x17, 0x26, 0xee,
	0x8b, 0xab, 0x54, 0xf5, 0xfc, 0x69, 0x0e, 0x49, 0xeb, 0x15, 0xa2, 0x95, 0xc6, 0x86, 0x30, 0x57,
	0x40, 0x2b, 0x5d, 0xcd, 0x89, 0x1f, 0x13, 0xc1, 0x3b, 0x1b, 0x7d, 0xa1, 0xc1, 0x7c, 0xdb, 0x4d,
	0x10, 0x35, 0x87, 0x5b, 0x29, 0x36, 0x7a, 0x34, 0xb3, 0x7a, 0x71, 0xd0, 0xf6, 0x31, 0x2d, 0x53,
	0xe2, 0x0e, 0xa7, 0x1c, 0xf6, 0x95, 0xe8, 0x5d, 0x0d, 0x26, 0xdb, 0x5a, 0x3d, 0x74, 0x79, 0x00,
	0x6a, 0x11, 0xa7, 0x0b, 0xfd, 0x38, 0xf9, 0x46, 0x41, 0x90, 0xd1, 0x51, 0x3e, 0x8d, 0x0c, 0xfa,
	0x56, 0x83, 0xf3, 0xbd, 0x1a, 0x25, 0xb4, 0x3d, 0x00, 0xa5, 0x94, 0xee, 0x4a, 0xff, 0x57, 0x5a,
	0x7a, 0x77, 0xe8, 0x1b, 0x9b, 0x82, 0xe7, 0x65, 0x74, 0x29, 0xd5, 0x69, 0xa2, 0x59, 0x20, 0x3e,
	0xe1, 0x96, 0xe2, 0x75, 0x02, 0x33, 0x49, 0x0a, 0xb2, 0x53, 0x49, 0x4b, 0xab, 0xf5, 0x7e, 0xae,
	0x12, 0xcb, 0xd3, 0x72, 0x2b, 0x41, 0xe3, 0x89, 0x30, 0xf3, 0xb5, 0xfa, 0xbd, 0xd1, 0xf5, 0x8e,
	0xbe, 0xd9, 0xe3, 0xe8, 0xf4, 0x68, 0x4b, 0xf4, 0xcb, 0x7f, 0xe3, 0xc2, 0x36, 0xae, 0x08, 0xa6,
	0x1b, 0xe8, 0x62, 0xba, 0xc3, 0x12, 0x94, 0xbe, 0xd1, 0xe0, 0x5c, 0xea, 0xa5, 0x85, 0xfe, 0x33,
	0x40, 0x84, 0xbb, 0x5d, 0x73, 0xfa, 0xd5, 0x7e, 0x8c, 0xdb, 0x56, 0xa5, 0x15, 0xaf, 0x04, 0xe7,
	0xb6, 0x8b, 0x6c, 0x67, 0xf7, 0xa7, 0x17, 0x2b, 0xda, 0xb3, 0x17, 0x2b, 0xda, 0x6f, 0x2f, 0x56,
	0xb4, 0x77, 0xfe, 0x9d, 0xf8, 0x9f, 0xe8, 0x7a, 0xc7, 0x7e, 0x13, 0x73, 0x6a, 0xd9, 0xb8, 0xea,
	0xcb, 0x51, 0xf9, 0xf4, 0x7f, 0xbb, 0xdb, 0x84, 0x37, 0xaa, 0x23, 0x42, 0x7e, 0xfd, 0xaf, 0x00,
	0x00, 0x00, 0xff, 0xff, 0xf0, 0x70, 0x21, 0xfc, 0xcd, 0x14, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// BeaconChainClient is the client API for BeaconChain service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type BeaconChainClient interface {
	ListAttestations(ctx context.Context, in *ListAttestationsRequest, opts ...grpc.CallOption) (*ListAttestationsResponse, error)
	AttestationPool(ctx context.Context, in *types.Empty, opts ...grpc.CallOption) (*AttestationPoolResponse, error)
	ListBlocks(ctx context.Context, in *ListBlocksRequest, opts ...grpc.CallOption) (*ListBlocksResponse, error)
	GetChainHead(ctx context.Context, in *types.Empty, opts ...grpc.CallOption) (*ChainHead, error)
	ListValidatorBalances(ctx context.Context, in *GetValidatorBalancesRequest, opts ...grpc.CallOption) (*ValidatorBalances, error)
	GetValidators(ctx context.Context, in *GetValidatorsRequest, opts ...grpc.CallOption) (*Validators, error)
	GetValidatorActiveSetChanges(ctx context.Context, in *GetValidatorActiveSetChangesRequest, opts ...grpc.CallOption) (*ActiveSetChanges, error)
	GetValidatorQueue(ctx context.Context, in *types.Empty, opts ...grpc.CallOption) (*ValidatorQueue, error)
	ListValidatorAssignments(ctx context.Context, in *ListValidatorAssignmentsRequest, opts ...grpc.CallOption) (*ValidatorAssignments, error)
	GetValidatorParticipation(ctx context.Context, in *GetValidatorParticipationRequest, opts ...grpc.CallOption) (*ValidatorParticipation, error)
}

type beaconChainClient struct {
	cc *grpc.ClientConn
}

func NewBeaconChainClient(cc *grpc.ClientConn) BeaconChainClient {
	return &beaconChainClient{cc}
}

func (c *beaconChainClient) ListAttestations(ctx context.Context, in *ListAttestationsRequest, opts ...grpc.CallOption) (*ListAttestationsResponse, error) {
	out := new(ListAttestationsResponse)
	err := c.cc.Invoke(ctx, "/ethereum.eth.v1alpha1.BeaconChain/ListAttestations", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *beaconChainClient) AttestationPool(ctx context.Context, in *types.Empty, opts ...grpc.CallOption) (*AttestationPoolResponse, error) {
	out := new(AttestationPoolResponse)
	err := c.cc.Invoke(ctx, "/ethereum.eth.v1alpha1.BeaconChain/AttestationPool", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *beaconChainClient) ListBlocks(ctx context.Context, in *ListBlocksRequest, opts ...grpc.CallOption) (*ListBlocksResponse, error) {
	out := new(ListBlocksResponse)
	err := c.cc.Invoke(ctx, "/ethereum.eth.v1alpha1.BeaconChain/ListBlocks", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *beaconChainClient) GetChainHead(ctx context.Context, in *types.Empty, opts ...grpc.CallOption) (*ChainHead, error) {
	out := new(ChainHead)
	err := c.cc.Invoke(ctx, "/ethereum.eth.v1alpha1.BeaconChain/GetChainHead", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *beaconChainClient) ListValidatorBalances(ctx context.Context, in *GetValidatorBalancesRequest, opts ...grpc.CallOption) (*ValidatorBalances, error) {
	out := new(ValidatorBalances)
	err := c.cc.Invoke(ctx, "/ethereum.eth.v1alpha1.BeaconChain/ListValidatorBalances", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *beaconChainClient) GetValidators(ctx context.Context, in *GetValidatorsRequest, opts ...grpc.CallOption) (*Validators, error) {
	out := new(Validators)
	err := c.cc.Invoke(ctx, "/ethereum.eth.v1alpha1.BeaconChain/GetValidators", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *beaconChainClient) GetValidatorActiveSetChanges(ctx context.Context, in *GetValidatorActiveSetChangesRequest, opts ...grpc.CallOption) (*ActiveSetChanges, error) {
	out := new(ActiveSetChanges)
	err := c.cc.Invoke(ctx, "/ethereum.eth.v1alpha1.BeaconChain/GetValidatorActiveSetChanges", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *beaconChainClient) GetValidatorQueue(ctx context.Context, in *types.Empty, opts ...grpc.CallOption) (*ValidatorQueue, error) {
	out := new(ValidatorQueue)
	err := c.cc.Invoke(ctx, "/ethereum.eth.v1alpha1.BeaconChain/GetValidatorQueue", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *beaconChainClient) ListValidatorAssignments(ctx context.Context, in *ListValidatorAssignmentsRequest, opts ...grpc.CallOption) (*ValidatorAssignments, error) {
	out := new(ValidatorAssignments)
	err := c.cc.Invoke(ctx, "/ethereum.eth.v1alpha1.BeaconChain/ListValidatorAssignments", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *beaconChainClient) GetValidatorParticipation(ctx context.Context, in *GetValidatorParticipationRequest, opts ...grpc.CallOption) (*ValidatorParticipation, error) {
	out := new(ValidatorParticipation)
	err := c.cc.Invoke(ctx, "/ethereum.eth.v1alpha1.BeaconChain/GetValidatorParticipation", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// BeaconChainServer is the server API for BeaconChain service.
type BeaconChainServer interface {
	ListAttestations(context.Context, *ListAttestationsRequest) (*ListAttestationsResponse, error)
	AttestationPool(context.Context, *types.Empty) (*AttestationPoolResponse, error)
	ListBlocks(context.Context, *ListBlocksRequest) (*ListBlocksResponse, error)
	GetChainHead(context.Context, *types.Empty) (*ChainHead, error)
	ListValidatorBalances(context.Context, *GetValidatorBalancesRequest) (*ValidatorBalances, error)
	GetValidators(context.Context, *GetValidatorsRequest) (*Validators, error)
	GetValidatorActiveSetChanges(context.Context, *GetValidatorActiveSetChangesRequest) (*ActiveSetChanges, error)
	GetValidatorQueue(context.Context, *types.Empty) (*ValidatorQueue, error)
	ListValidatorAssignments(context.Context, *ListValidatorAssignmentsRequest) (*ValidatorAssignments, error)
	GetValidatorParticipation(context.Context, *GetValidatorParticipationRequest) (*ValidatorParticipation, error)
}

func RegisterBeaconChainServer(s *grpc.Server, srv BeaconChainServer) {
	s.RegisterService(&_BeaconChain_serviceDesc, srv)
}

func _BeaconChain_ListAttestations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListAttestationsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BeaconChainServer).ListAttestations(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ethereum.eth.v1alpha1.BeaconChain/ListAttestations",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BeaconChainServer).ListAttestations(ctx, req.(*ListAttestationsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BeaconChain_AttestationPool_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(types.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BeaconChainServer).AttestationPool(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ethereum.eth.v1alpha1.BeaconChain/AttestationPool",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BeaconChainServer).AttestationPool(ctx, req.(*types.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _BeaconChain_ListBlocks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListBlocksRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BeaconChainServer).ListBlocks(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ethereum.eth.v1alpha1.BeaconChain/ListBlocks",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BeaconChainServer).ListBlocks(ctx, req.(*ListBlocksRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BeaconChain_GetChainHead_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(types.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BeaconChainServer).GetChainHead(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ethereum.eth.v1alpha1.BeaconChain/GetChainHead",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BeaconChainServer).GetChainHead(ctx, req.(*types.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _BeaconChain_ListValidatorBalances_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetValidatorBalancesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BeaconChainServer).ListValidatorBalances(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ethereum.eth.v1alpha1.BeaconChain/ListValidatorBalances",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BeaconChainServer).ListValidatorBalances(ctx, req.(*GetValidatorBalancesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BeaconChain_GetValidators_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetValidatorsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BeaconChainServer).GetValidators(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ethereum.eth.v1alpha1.BeaconChain/GetValidators",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BeaconChainServer).GetValidators(ctx, req.(*GetValidatorsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BeaconChain_GetValidatorActiveSetChanges_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetValidatorActiveSetChangesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BeaconChainServer).GetValidatorActiveSetChanges(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ethereum.eth.v1alpha1.BeaconChain/GetValidatorActiveSetChanges",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BeaconChainServer).GetValidatorActiveSetChanges(ctx, req.(*GetValidatorActiveSetChangesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BeaconChain_GetValidatorQueue_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(types.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BeaconChainServer).GetValidatorQueue(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ethereum.eth.v1alpha1.BeaconChain/GetValidatorQueue",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BeaconChainServer).GetValidatorQueue(ctx, req.(*types.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _BeaconChain_ListValidatorAssignments_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListValidatorAssignmentsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BeaconChainServer).ListValidatorAssignments(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ethereum.eth.v1alpha1.BeaconChain/ListValidatorAssignments",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BeaconChainServer).ListValidatorAssignments(ctx, req.(*ListValidatorAssignmentsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BeaconChain_GetValidatorParticipation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetValidatorParticipationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BeaconChainServer).GetValidatorParticipation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ethereum.eth.v1alpha1.BeaconChain/GetValidatorParticipation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BeaconChainServer).GetValidatorParticipation(ctx, req.(*GetValidatorParticipationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _BeaconChain_serviceDesc = grpc.ServiceDesc{
	ServiceName: "ethereum.eth.v1alpha1.BeaconChain",
	HandlerType: (*BeaconChainServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListAttestations",
			Handler:    _BeaconChain_ListAttestations_Handler,
		},
		{
			MethodName: "AttestationPool",
			Handler:    _BeaconChain_AttestationPool_Handler,
		},
		{
			MethodName: "ListBlocks",
			Handler:    _BeaconChain_ListBlocks_Handler,
		},
		{
			MethodName: "GetChainHead",
			Handler:    _BeaconChain_GetChainHead_Handler,
		},
		{
			MethodName: "ListValidatorBalances",
			Handler:    _BeaconChain_ListValidatorBalances_Handler,
		},
		{
			MethodName: "GetValidators",
			Handler:    _BeaconChain_GetValidators_Handler,
		},
		{
			MethodName: "GetValidatorActiveSetChanges",
			Handler:    _BeaconChain_GetValidatorActiveSetChanges_Handler,
		},
		{
			MethodName: "GetValidatorQueue",
			Handler:    _BeaconChain_GetValidatorQueue_Handler,
		},
		{
			MethodName: "ListValidatorAssignments",
			Handler:    _BeaconChain_ListValidatorAssignments_Handler,
		},
		{
			MethodName: "GetValidatorParticipation",
			Handler:    _BeaconChain_GetValidatorParticipation_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/eth/v1alpha1/beacon_chain.proto",
}

func (m *ListAttestationsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListAttestationsRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.QueryFilter != nil {
		nn1, err := m.QueryFilter.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn1
	}
	if m.PageSize != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintBeaconChain(dAtA, i, uint64(m.PageSize))
	}
	if len(m.PageToken) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintBeaconChain(dAtA, i, uint64(len(m.PageToken)))
		i += copy(dAtA[i:], m.PageToken)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ListAttestationsRequest_HeadBlockRoot) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.HeadBlockRoot != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBeaconChain(dAtA, i, uint64(len(m.HeadBlockRoot)))
		i += copy(dAtA[i:], m.HeadBlockRoot)
	}
	return i, nil
}
func (m *ListAttestationsRequest_SourceEpoch) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x10
	i++
	i = encodeVarintBeaconChain(dAtA, i, uint64(m.SourceEpoch))
	return i, nil
}
func (m *ListAttestationsRequest_SourceRoot) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.SourceRoot != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintBeaconChain(dAtA, i, uint64(len(m.SourceRoot)))
		i += copy(dAtA[i:], m.SourceRoot)
	}
	return i, nil
}
func (m *ListAttestationsRequest_TargetEpoch) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x20
	i++
	i = encodeVarintBeaconChain(dAtA, i, uint64(m.TargetEpoch))
	return i, nil
}
func (m *ListAttestationsRequest_TargetRoot) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.TargetRoot != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintBeaconChain(dAtA, i, uint64(len(m.TargetRoot)))
		i += copy(dAtA[i:], m.TargetRoot)
	}
	return i, nil
}
func (m *ListAttestationsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListAttestationsResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Attestations) > 0 {
		for _, msg := range m.Attestations {
			dAtA[i] = 0xa
			i++
			i = encodeVarintBeaconChain(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.NextPageToken) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintBeaconChain(dAtA, i, uint64(len(m.NextPageToken)))
		i += copy(dAtA[i:], m.NextPageToken)
	}
	if m.TotalSize != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintBeaconChain(dAtA, i, uint64(m.TotalSize))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ListBlocksRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListBlocksRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.QueryFilter != nil {
		nn2, err := m.QueryFilter.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn2
	}
	if m.IncludeNoncanonical {
		dAtA[i] = 0x20
		i++
		if m.IncludeNoncanonical {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.PageSize != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintBeaconChain(dAtA, i, uint64(m.PageSize))
	}
	if len(m.PageToken) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintBeaconChain(dAtA, i, uint64(len(m.PageToken)))
		i += copy(dAtA[i:], m.PageToken)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ListBlocksRequest_Root) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Root != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBeaconChain(dAtA, i, uint64(len(m.Root)))
		i += copy(dAtA[i:], m.Root)
	}
	return i, nil
}
func (m *ListBlocksRequest_Slot) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x10
	i++
	i = encodeVarintBeaconChain(dAtA, i, uint64(m.Slot))
	return i, nil
}
func (m *ListBlocksRequest_Epoch) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x18
	i++
	i = encodeVarintBeaconChain(dAtA, i, uint64(m.Epoch))
	return i, nil
}
func (m *ListBlocksResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListBlocksResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Blocks) > 0 {
		for _, msg := range m.Blocks {
			dAtA[i] = 0xa
			i++
			i = encodeVarintBeaconChain(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.NextPageToken) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintBeaconChain(dAtA, i, uint64(len(m.NextPageToken)))
		i += copy(dAtA[i:], m.NextPageToken)
	}
	if m.TotalSize != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintBeaconChain(dAtA, i, uint64(m.TotalSize))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ChainHead) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChainHead) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.BlockRoot) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBeaconChain(dAtA, i, uint64(len(m.BlockRoot)))
		i += copy(dAtA[i:], m.BlockRoot)
	}
	if m.BlockSlot != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintBeaconChain(dAtA, i, uint64(m.BlockSlot))
	}
	if m.FinalizedSlot != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintBeaconChain(dAtA, i, uint64(m.FinalizedSlot))
	}
	if len(m.FinalizedBlockRoot) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintBeaconChain(dAtA, i, uint64(len(m.FinalizedBlockRoot)))
		i += copy(dAtA[i:], m.FinalizedBlockRoot)
	}
	if m.JustifiedSlot != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintBeaconChain(dAtA, i, uint64(m.JustifiedSlot))
	}
	if len(m.JustifiedBlockRoot) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintBeaconChain(dAtA, i, uint64(len(m.JustifiedBlockRoot)))
		i += copy(dAtA[i:], m.JustifiedBlockRoot)
	}
	if m.PreviousJustifiedSlot != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintBeaconChain(dAtA, i, uint64(m.PreviousJustifiedSlot))
	}
	if len(m.PreviousJustifiedBlockRoot) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintBeaconChain(dAtA, i, uint64(len(m.PreviousJustifiedBlockRoot)))
		i += copy(dAtA[i:], m.PreviousJustifiedBlockRoot)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GetValidatorBalancesRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetValidatorBalancesRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Epoch != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBeaconChain(dAtA, i, uint64(m.Epoch))
	}
	if len(m.PublicKeys) > 0 {
		for _, b := range m.PublicKeys {
			dAtA[i] = 0x12
			i++
			i = encodeVarintBeaconChain(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if len(m.Indices) > 0 {
		dAtA4 := make([]byte, len(m.Indices)*10)
		var j3 int
		for _, num := range m.Indices {
			for num >= 1<<7 {
				dAtA4[j3] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j3++
			}
			dAtA4[j3] = uint8(num)
			j3++
		}
		dAtA[i] = 0x1a
		i++
		i = encodeVarintBeaconChain(dAtA, i, uint64(j3))
		i += copy(dAtA[i:], dAtA4[:j3])
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ValidatorBalances) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValidatorBalances) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Balances) > 0 {
		for _, msg := range m.Balances {
			dAtA[i] = 0xa
			i++
			i = encodeVarintBeaconChain(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ValidatorBalances_Balance) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValidatorBalances_Balance) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PublicKey) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBeaconChain(dAtA, i, uint64(len(m.PublicKey)))
		i += copy(dAtA[i:], m.PublicKey)
	}
	if m.Index != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintBeaconChain(dAtA, i, uint64(m.Index))
	}
	if m.Balance != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintBeaconChain(dAtA, i, uint64(m.Balance))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GetValidatorsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetValidatorsRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.QueryFilter != nil {
		nn5, err := m.QueryFilter.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn5
	}
	if m.PageSize != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintBeaconChain(dAtA, i, uint64(m.PageSize))
	}
	if len(m.PageToken) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintBeaconChain(dAtA, i, uint64(len(m.PageToken)))
		i += copy(dAtA[i:], m.PageToken)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GetValidatorsRequest_Epoch) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x8
	i++
	i = encodeVarintBeaconChain(dAtA, i, uint64(m.Epoch))
	return i, nil
}
func (m *GetValidatorsRequest_Genesis) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x10
	i++
	if m.Genesis {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	return i, nil
}
func (m *Validators) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Validators) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Epoch != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBeaconChain(dAtA, i, uint64(m.Epoch))
	}
	if len(m.Validators) > 0 {
		for _, msg := range m.Validators {
			dAtA[i] = 0x12
			i++
			i = encodeVarintBeaconChain(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.NextPageToken) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintBeaconChain(dAtA, i, uint64(len(m.NextPageToken)))
		i += copy(dAtA[i:], m.NextPageToken)
	}
	if m.TotalSize != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintBeaconChain(dAtA, i, uint64(m.TotalSize))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GetValidatorActiveSetChangesRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetValidatorActiveSetChangesRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Epoch != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBeaconChain(dAtA, i, uint64(m.Epoch))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ActiveSetChanges) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActiveSetChanges) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Epoch != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBeaconChain(dAtA, i, uint64(m.Epoch))
	}
	if len(m.ActivatedPublicKeys) > 0 {
		for _, b := range m.ActivatedPublicKeys {
			dAtA[i] = 0x12
			i++
			i = encodeVarintBeaconChain(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if len(m.ExitedPublicKeys) > 0 {
		for _, b := range m.ExitedPublicKeys {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintBeaconChain(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if len(m.EjectedPublicKeys) > 0 {
		for _, b := range m.EjectedPublicKeys {
			dAtA[i] = 0x22
			i++
			i = encodeVarintBeaconChain(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ValidatorQueue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValidatorQueue) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ChurnLimit != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBeaconChain(dAtA, i, uint64(m.ChurnLimit))
	}
	if len(m.ActivationPublicKeys) > 0 {
		for _, b := range m.ActivationPublicKeys {
			dAtA[i] = 0x12
			i++
			i = encodeVarintBeaconChain(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if len(m.ExitPublicKeys) > 0 {
		for _, b := range m.ExitPublicKeys {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintBeaconChain(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ListValidatorAssignmentsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListValidatorAssignmentsRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Epoch != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBeaconChain(dAtA, i, uint64(m.Epoch))
	}
	if len(m.PublicKeys) > 0 {
		for _, b := range m.PublicKeys {
			dAtA[i] = 0x12
			i++
			i = encodeVarintBeaconChain(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if len(m.Indices) > 0 {
		dAtA7 := make([]byte, len(m.Indices)*10)
		var j6 int
		for _, num := range m.Indices {
			for num >= 1<<7 {
				dAtA7[j6] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j6++
			}
			dAtA7[j6] = uint8(num)
			j6++
		}
		dAtA[i] = 0x1a
		i++
		i = encodeVarintBeaconChain(dAtA, i, uint64(j6))
		i += copy(dAtA[i:], dAtA7[:j6])
	}
	if m.PageSize != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintBeaconChain(dAtA, i, uint64(m.PageSize))
	}
	if len(m.PageToken) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintBeaconChain(dAtA, i, uint64(len(m.PageToken)))
		i += copy(dAtA[i:], m.PageToken)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ValidatorAssignments) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValidatorAssignments) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Epoch != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBeaconChain(dAtA, i, uint64(m.Epoch))
	}
	if len(m.Assignments) > 0 {
		for _, msg := range m.Assignments {
			dAtA[i] = 0x12
			i++
			i = encodeVarintBeaconChain(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.NextPageToken) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintBeaconChain(dAtA, i, uint64(len(m.NextPageToken)))
		i += copy(dAtA[i:], m.NextPageToken)
	}
	if m.TotalSize != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintBeaconChain(dAtA, i, uint64(m.TotalSize))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ValidatorAssignments_CommitteeAssignment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValidatorAssignments_CommitteeAssignment) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.CrosslinkCommittees) > 0 {
		dAtA9 := make([]byte, len(m.CrosslinkCommittees)*10)
		var j8 int
		for _, num := range m.CrosslinkCommittees {
			for num >= 1<<7 {
				dAtA9[j8] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j8++
			}
			dAtA9[j8] = uint8(num)
			j8++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintBeaconChain(dAtA, i, uint64(j8))
		i += copy(dAtA[i:], dAtA9[:j8])
	}
	if m.Shard != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintBeaconChain(dAtA, i, uint64(m.Shard))
	}
	if m.Slot != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintBeaconChain(dAtA, i, uint64(m.Slot))
	}
	if m.Proposer {
		dAtA[i] = 0x20
		i++
		if m.Proposer {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.PublicKey) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintBeaconChain(dAtA, i, uint64(len(m.PublicKey)))
		i += copy(dAtA[i:], m.PublicKey)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GetValidatorParticipationRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetValidatorParticipationRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Epoch != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBeaconChain(dAtA, i, uint64(m.Epoch))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ValidatorParticipation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValidatorParticipation) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Epoch != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBeaconChain(dAtA, i, uint64(m.Epoch))
	}
	if m.Finalized {
		dAtA[i] = 0x10
		i++
		if m.Finalized {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.GlobalParticipationRate != 0 {
		dAtA[i] = 0x1d
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.GlobalParticipationRate))))
		i += 4
	}
	if m.VotedEther != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintBeaconChain(dAtA, i, uint64(m.VotedEther))
	}
	if m.EligibleEther != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintBeaconChain(dAtA, i, uint64(m.EligibleEther))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AttestationPoolResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AttestationPoolResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Attestations) > 0 {
		for _, msg := range m.Attestations {
			dAtA[i] = 0xa
			i++
			i = encodeVarintBeaconChain(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintBeaconChain(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *ListAttestationsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.QueryFilter != nil {
		n += m.QueryFilter.Size()
	}
	if m.PageSize != 0 {
		n += 1 + sovBeaconChain(uint64(m.PageSize))
	}
	l = len(m.PageToken)
	if l > 0 {
		n += 1 + l + sovBeaconChain(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListAttestationsRequest_HeadBlockRoot) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HeadBlockRoot != nil {
		l = len(m.HeadBlockRoot)
		n += 1 + l + sovBeaconChain(uint64(l))
	}
	return n
}
func (m *ListAttestationsRequest_SourceEpoch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovBeaconChain(uint64(m.SourceEpoch))
	return n
}
func (m *ListAttestationsRequest_SourceRoot) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SourceRoot != nil {
		l = len(m.SourceRoot)
		n += 1 + l + sovBeaconChain(uint64(l))
	}
	return n
}
func (m *ListAttestationsRequest_TargetEpoch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovBeaconChain(uint64(m.TargetEpoch))
	return n
}
func (m *ListAttestationsRequest_TargetRoot) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TargetRoot != nil {
		l = len(m.TargetRoot)
		n += 1 + l + sovBeaconChain(uint64(l))
	}
	return n
}
func (m *ListAttestationsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Attestations) > 0 {
		for _, e := range m.Attestations {
			l = e.Size()
			n += 1 + l + sovBeaconChain(uint64(l))
		}
	}
	l = len(m.NextPageToken)
	if l > 0 {
		n += 1 + l + sovBeaconChain(uint64(l))
	}
	if m.TotalSize != 0 {
		n += 1 + sovBeaconChain(uint64(m.TotalSize))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListBlocksRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.QueryFilter != nil {
		n += m.QueryFilter.Size()
	}
	if m.IncludeNoncanonical {
		n += 2
	}
	if m.PageSize != 0 {
		n += 1 + sovBeaconChain(uint64(m.PageSize))
	}
	l = len(m.PageToken)
	if l > 0 {
		n += 1 + l + sovBeaconChain(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListBlocksRequest_Root) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Root != nil {
		l = len(m.Root)
		n += 1 + l + sovBeaconChain(uint64(l))
	}
	return n
}
func (m *ListBlocksRequest_Slot) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovBeaconChain(uint64(m.Slot))
	return n
}
func (m *ListBlocksRequest_Epoch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovBeaconChain(uint64(m.Epoch))
	return n
}
func (m *ListBlocksResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Blocks) > 0 {
		for _, e := range m.Blocks {
			l = e.Size()
			n += 1 + l + sovBeaconChain(uint64(l))
		}
	}
	l = len(m.NextPageToken)
	if l > 0 {
		n += 1 + l + sovBeaconChain(uint64(l))
	}
	if m.TotalSize != 0 {
		n += 1 + sovBeaconChain(uint64(m.TotalSize))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ChainHead) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.BlockRoot)
	if l > 0 {
		n += 1 + l + sovBeaconChain(uint64(l))
	}
	if m.BlockSlot != 0 {
		n += 1 + sovBeaconChain(uint64(m.BlockSlot))
	}
	if m.FinalizedSlot != 0 {
		n += 1 + sovBeaconChain(uint64(m.FinalizedSlot))
	}
	l = len(m.FinalizedBlockRoot)
	if l > 0 {
		n += 1 + l + sovBeaconChain(uint64(l))
	}
	if m.JustifiedSlot != 0 {
		n += 1 + sovBeaconChain(uint64(m.JustifiedSlot))
	}
	l = len(m.JustifiedBlockRoot)
	if l > 0 {
		n += 1 + l + sovBeaconChain(uint64(l))
	}
	if m.PreviousJustifiedSlot != 0 {
		n += 1 + sovBeaconChain(uint64(m.PreviousJustifiedSlot))
	}
	l = len(m.PreviousJustifiedBlockRoot)
	if l > 0 {
		n += 1 + l + sovBeaconChain(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetValidatorBalancesRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Epoch != 0 {
		n += 1 + sovBeaconChain(uint64(m.Epoch))
	}
	if len(m.PublicKeys) > 0 {
		for _, b := range m.PublicKeys {
			l = len(b)
			n += 1 + l + sovBeaconChain(uint64(l))
		}
	}
	if len(m.Indices) > 0 {
		l = 0
		for _, e := range m.Indices {
			l += sovBeaconChain(uint64(e))
		}
		n += 1 + sovBeaconChain(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ValidatorBalances) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Balances) > 0 {
		for _, e := range m.Balances {
			l = e.Size()
			n += 1 + l + sovBeaconChain(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ValidatorBalances_Balance) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PublicKey)
	if l > 0 {
		n += 1 + l + sovBeaconChain(uint64(l))
	}
	if m.Index != 0 {
		n += 1 + sovBeaconChain(uint64(m.Index))
	}
	if m.Balance != 0 {
		n += 1 + sovBeaconChain(uint64(m.Balance))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetValidatorsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.QueryFilter != nil {
		n += m.QueryFilter.Size()
	}
	if m.PageSize != 0 {
		n += 1 + sovBeaconChain(uint64(m.PageSize))
	}
	l = len(m.PageToken)
	if l > 0 {
		n += 1 + l + sovBeaconChain(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetValidatorsRequest_Epoch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovBeaconChain(uint64(m.Epoch))
	return n
}
func (m *GetValidatorsRequest_Genesis) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	return n
}
func (m *Validators) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Epoch != 0 {
		n += 1 + sovBeaconChain(uint64(m.Epoch))
	}
	if len(m.Validators) > 0 {
		for _, e := range m.Validators {
			l = e.Size()
			n += 1 + l + sovBeaconChain(uint64(l))
		}
	}
	l = len(m.NextPageToken)
	if l > 0 {
		n += 1 + l + sovBeaconChain(uint64(l))
	}
	if m.TotalSize != 0 {
		n += 1 + sovBeaconChain(uint64(m.TotalSize))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetValidatorActiveSetChangesRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Epoch != 0 {
		n += 1 + sovBeaconChain(uint64(m.Epoch))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ActiveSetChanges) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Epoch != 0 {
		n += 1 + sovBeaconChain(uint64(m.Epoch))
	}
	if len(m.ActivatedPublicKeys) > 0 {
		for _, b := range m.ActivatedPublicKeys {
			l = len(b)
			n += 1 + l + sovBeaconChain(uint64(l))
		}
	}
	if len(m.ExitedPublicKeys) > 0 {
		for _, b := range m.ExitedPublicKeys {
			l = len(b)
			n += 1 + l + sovBeaconChain(uint64(l))
		}
	}
	if len(m.EjectedPublicKeys) > 0 {
		for _, b := range m.EjectedPublicKeys {
			l = len(b)
			n += 1 + l + sovBeaconChain(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ValidatorQueue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ChurnLimit != 0 {
		n += 1 + sovBeaconChain(uint64(m.ChurnLimit))
	}
	if len(m.ActivationPublicKeys) > 0 {
		for _, b := range m.ActivationPublicKeys {
			l = len(b)
			n += 1 + l + sovBeaconChain(uint64(l))
		}
	}
	if len(m.ExitPublicKeys) > 0 {
		for _, b := range m.ExitPublicKeys {
			l = len(b)
			n += 1 + l + sovBeaconChain(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListValidatorAssignmentsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Epoch != 0 {
		n += 1 + sovBeaconChain(uint64(m.Epoch))
	}
	if len(m.PublicKeys) > 0 {
		for _, b := range m.PublicKeys {
			l = len(b)
			n += 1 + l + sovBeaconChain(uint64(l))
		}
	}
	if len(m.Indices) > 0 {
		l = 0
		for _, e := range m.Indices {
			l += sovBeaconChain(uint64(e))
		}
		n += 1 + sovBeaconChain(uint64(l)) + l
	}
	if m.PageSize != 0 {
		n += 1 + sovBeaconChain(uint64(m.PageSize))
	}
	l = len(m.PageToken)
	if l > 0 {
		n += 1 + l + sovBeaconChain(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ValidatorAssignments) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Epoch != 0 {
		n += 1 + sovBeaconChain(uint64(m.Epoch))
	}
	if len(m.Assignments) > 0 {
		for _, e := range m.Assignments {
			l = e.Size()
			n += 1 + l + sovBeaconChain(uint64(l))
		}
	}
	l = len(m.NextPageToken)
	if l > 0 {
		n += 1 + l + sovBeaconChain(uint64(l))
	}
	if m.TotalSize != 0 {
		n += 1 + sovBeaconChain(uint64(m.TotalSize))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ValidatorAssignments_CommitteeAssignment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.CrosslinkCommittees) > 0 {
		l = 0
		for _, e := range m.CrosslinkCommittees {
			l += sovBeaconChain(uint64(e))
		}
		n += 1 + sovBeaconChain(uint64(l)) + l
	}
	if m.Shard != 0 {
		n += 1 + sovBeaconChain(uint64(m.Shard))
	}
	if m.Slot != 0 {
		n += 1 + sovBeaconChain(uint64(m.Slot))
	}
	if m.Proposer {
		n += 2
	}
	l = len(m.PublicKey)
	if l > 0 {
		n += 1 + l + sovBeaconChain(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetValidatorParticipationRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Epoch != 0 {
		n += 1 + sovBeaconChain(uint64(m.Epoch))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ValidatorParticipation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Epoch != 0 {
		n += 1 + sovBeaconChain(uint64(m.Epoch))
	}
	if m.Finalized {
		n += 2
	}
	if m.GlobalParticipationRate != 0 {
		n += 5
	}
	if m.VotedEther != 0 {
		n += 1 + sovBeaconChain(uint64(m.VotedEther))
	}
	if m.EligibleEther != 0 {
		n += 1 + sovBeaconChain(uint64(m.EligibleEther))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AttestationPoolResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Attestations) > 0 {
		for _, e := range m.Attestations {
			l = e.Size()
			n += 1 + l + sovBeaconChain(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovBeaconChain(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozBeaconChain(x uint64) (n int) {
	return sovBeaconChain(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ListAttestationsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBeaconChain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListAttestationsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListAttestationsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeadBlockRoot", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBeaconChain
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := make([]byte, postIndex-iNdEx)
			copy(v, dAtA[iNdEx:postIndex])
			m.QueryFilter = &ListAttestationsRequest_HeadBlockRoot{v}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceEpoch", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.QueryFilter = &ListAttestationsRequest_SourceEpoch{v}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceRoot", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBeaconChain
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := make([]byte, postIndex-iNdEx)
			copy(v, dAtA[iNdEx:postIndex])
			m.QueryFilter = &ListAttestationsRequest_SourceRoot{v}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetEpoch", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.QueryFilter = &ListAttestationsRequest_TargetEpoch{v}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetRoot", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBeaconChain
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := make([]byte, postIndex-iNdEx)
			copy(v, dAtA[iNdEx:postIndex])
			m.QueryFilter = &ListAttestationsRequest_TargetRoot{v}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageSize", wireType)
			}
			m.PageSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PageSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBeaconChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PageToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBeaconChain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListAttestationsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBeaconChain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListAttestationsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListAttestationsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attestations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBeaconChain
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Attestations = append(m.Attestations, &Attestation{})
			if err := m.Attestations[len(m.Attestations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextPageToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBeaconChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NextPageToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalSize", wireType)
			}
			m.TotalSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBeaconChain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListBlocksRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBeaconChain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListBlocksRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListBlocksRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Root", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBeaconChain
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := make([]byte, postIndex-iNdEx)
			copy(v, dAtA[iNdEx:postIndex])
			m.QueryFilter = &ListBlocksRequest_Root{v}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Slot", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.QueryFilter = &ListBlocksRequest_Slot{v}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.QueryFilter = &ListBlocksRequest_Epoch{v}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IncludeNoncanonical", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IncludeNoncanonical = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageSize", wireType)
			}
			m.PageSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PageSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBeaconChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PageToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBeaconChain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListBlocksResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBeaconChain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListBlocksResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListBlocksResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Blocks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBeaconChain
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Blocks = append(m.Blocks, &BeaconBlock{})
			if err := m.Blocks[len(m.Blocks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextPageToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBeaconChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NextPageToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalSize", wireType)
			}
			m.TotalSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBeaconChain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChainHead) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBeaconChain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChainHead: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChainHead: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockRoot", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBeaconChain
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BlockRoot = append(m.BlockRoot[:0], dAtA[iNdEx:postIndex]...)
			if m.BlockRoot == nil {
				m.BlockRoot = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockSlot", wireType)
			}
			m.BlockSlot = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockSlot |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FinalizedSlot", wireType)
			}
			m.FinalizedSlot = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FinalizedSlot |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FinalizedBlockRoot", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBeaconChain
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FinalizedBlockRoot = append(m.FinalizedBlockRoot[:0], dAtA[iNdEx:postIndex]...)
			if m.FinalizedBlockRoot == nil {
				m.FinalizedBlockRoot = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JustifiedSlot", wireType)
			}
			m.JustifiedSlot = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JustifiedSlot |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JustifiedBlockRoot", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBeaconChain
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JustifiedBlockRoot = append(m.JustifiedBlockRoot[:0], dAtA[iNdEx:postIndex]...)
			if m.JustifiedBlockRoot == nil {
				m.JustifiedBlockRoot = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreviousJustifiedSlot", wireType)
			}
			m.PreviousJustifiedSlot = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PreviousJustifiedSlot |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreviousJustifiedBlockRoot", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBeaconChain
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PreviousJustifiedBlockRoot = append(m.PreviousJustifiedBlockRoot[:0], dAtA[iNdEx:postIndex]...)
			if m.PreviousJustifiedBlockRoot == nil {
				m.PreviousJustifiedBlockRoot = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBeaconChain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetValidatorBalancesRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBeaconChain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetValidatorBalancesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetValidatorBalancesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			m.Epoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Epoch |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicKeys", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBeaconChain
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PublicKeys = append(m.PublicKeys, make([]byte, postIndex-iNdEx))
			copy(m.PublicKeys[len(m.PublicKeys)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBeaconChain
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Indices = append(m.Indices, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBeaconChain
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthBeaconChain
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthBeaconChain
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Indices) == 0 {
					m.Indices = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBeaconChain
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Indices = append(m.Indices, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Indices", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBeaconChain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ValidatorBalances) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBeaconChain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValidatorBalances: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValidatorBalances: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Balances", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBeaconChain
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Balances = append(m.Balances, &ValidatorBalances_Balance{})
			if err := m.Balances[len(m.Balances)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBeaconChain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ValidatorBalances_Balance) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBeaconChain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Balance: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Balance: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBeaconChain
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PublicKey = append(m.PublicKey[:0], dAtA[iNdEx:postIndex]...)
			if m.PublicKey == nil {
				m.PublicKey = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Balance", wireType)
			}
			m.Balance = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Balance |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBeaconChain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetValidatorsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBeaconChain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetValidatorsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetValidatorsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.QueryFilter = &GetValidatorsRequest_Epoch{v}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Genesis", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.QueryFilter = &GetValidatorsRequest_Genesis{b}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageSize", wireType)
			}
			m.PageSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PageSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBeaconChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PageToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBeaconChain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Validators) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBeaconChain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Validators: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Validators: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			m.Epoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Epoch |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Validators", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBeaconChain
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Validators = append(m.Validators, &Validator{})
			if err := m.Validators[len(m.Validators)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextPageToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBeaconChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NextPageToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalSize", wireType)
			}
			m.TotalSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBeaconChain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetValidatorActiveSetChangesRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBeaconChain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetValidatorActiveSetChangesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetValidatorActiveSetChangesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			m.Epoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Epoch |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBeaconChain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActiveSetChanges) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBeaconChain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActiveSetChanges: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActiveSetChanges: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			m.Epoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Epoch |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActivatedPublicKeys", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBeaconChain
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ActivatedPublicKeys = append(m.ActivatedPublicKeys, make([]byte, postIndex-iNdEx))
			copy(m.ActivatedPublicKeys[len(m.ActivatedPublicKeys)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExitedPublicKeys", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBeaconChain
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExitedPublicKeys = append(m.ExitedPublicKeys, make([]byte, postIndex-iNdEx))
			copy(m.ExitedPublicKeys[len(m.ExitedPublicKeys)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EjectedPublicKeys", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBeaconChain
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EjectedPublicKeys = append(m.EjectedPublicKeys, make([]byte, postIndex-iNdEx))
			copy(m.EjectedPublicKeys[len(m.EjectedPublicKeys)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBeaconChain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ValidatorQueue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBeaconChain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValidatorQueue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValidatorQueue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChurnLimit", wireType)
			}
			m.ChurnLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChurnLimit |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActivationPublicKeys", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBeaconChain
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ActivationPublicKeys = append(m.ActivationPublicKeys, make([]byte, postIndex-iNdEx))
			copy(m.ActivationPublicKeys[len(m.ActivationPublicKeys)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExitPublicKeys", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBeaconChain
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExitPublicKeys = append(m.ExitPublicKeys, make([]byte, postIndex-iNdEx))
			copy(m.ExitPublicKeys[len(m.ExitPublicKeys)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBeaconChain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListValidatorAssignmentsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBeaconChain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListValidatorAssignmentsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListValidatorAssignmentsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			m.Epoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Epoch |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicKeys", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBeaconChain
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PublicKeys = append(m.PublicKeys, make([]byte, postIndex-iNdEx))
			copy(m.PublicKeys[len(m.PublicKeys)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBeaconChain
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Indices = append(m.Indices, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBeaconChain
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthBeaconChain
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthBeaconChain
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Indices) == 0 {
					m.Indices = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBeaconChain
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Indices = append(m.Indices, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Indices", wireType)
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageSize", wireType)
			}
			m.PageSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PageSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBeaconChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PageToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBeaconChain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ValidatorAssignments) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBeaconChain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValidatorAssignments: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValidatorAssignments: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			m.Epoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Epoch |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Assignments", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBeaconChain
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Assignments = append(m.Assignments, &ValidatorAssignments_CommitteeAssignment{})
			if err := m.Assignments[len(m.Assignments)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextPageToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBeaconChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NextPageToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalSize", wireType)
			}
			m.TotalSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBeaconChain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ValidatorAssignments_CommitteeAssignment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBeaconChain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommitteeAssignment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommitteeAssignment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBeaconChain
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.CrosslinkCommittees = append(m.CrosslinkCommittees, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBeaconChain
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthBeaconChain
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthBeaconChain
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.CrosslinkCommittees) == 0 {
					m.CrosslinkCommittees = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBeaconChain
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.CrosslinkCommittees = append(m.CrosslinkCommittees, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CrosslinkCommittees", wireType)
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shard", wireType)
			}
			m.Shard = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Shard |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Slot", wireType)
			}
			m.Slot = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Slot |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proposer", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Proposer = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBeaconChain
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PublicKey = append(m.PublicKey[:0], dAtA[iNdEx:postIndex]...)
			if m.PublicKey == nil {
				m.PublicKey = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBeaconChain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetValidatorParticipationRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBeaconChain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetValidatorParticipationRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetValidatorParticipationRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			m.Epoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Epoch |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBeaconChain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ValidatorParticipation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBeaconChain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValidatorParticipation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValidatorParticipation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			m.Epoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Epoch |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Finalized", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Finalized = bool(v != 0)
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field GlobalParticipationRate", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.GlobalParticipationRate = float32(math.Float32frombits(v))
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VotedEther", wireType)
			}
			m.VotedEther = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VotedEther |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EligibleEther", wireType)
			}
			m.EligibleEther = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EligibleEther |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBeaconChain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AttestationPoolResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBeaconChain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AttestationPoolResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AttestationPoolResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attestations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBeaconChain
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Attestations = append(m.Attestations, &Attestation{})
			if err := m.Attestations[len(m.Attestations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBeaconChain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipBeaconChain(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowBeaconChain
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthBeaconChain
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthBeaconChain
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowBeaconChain
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipBeaconChain(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthBeaconChain
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthBeaconChain = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowBeaconChain   = fmt.Errorf("proto: integer overflow")
)
